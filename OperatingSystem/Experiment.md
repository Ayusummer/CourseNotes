# 前言
## 实验环境
- 软件:
  - VisualStudio2019Community


---
# 第1次实验 实验2 同步机构

---
## 实验内容
- 模拟实现用同步机构避免并发进程执行时可能出现的与时间有关的错误

---
## 实验目的
- 进程是程序在一个数据集合上运行的过程，进程是并发执行的，也即系统中的多个进程轮流地占用处理器运行。
- 我们把如干个进程都能进行访问和修改地那些变量成为公共变量。
- 由于进程是并发执行的，所以，如果对进程访问公共变量不加限制，那么就会产生“与时间有关”的错误，
  - 即进程执行后，所得到的结果与访问公共变量的时间有关。为了防止这类错误，系统必须要用同步机构来控制进程对公共变量的访问。一般说，同步机构是由若干条原语——同步原语— —所组成。本实验要求学生模拟 PV 操作同步机构的实现，模拟进程的并发执行，了解进程并发执行时同步机构的作用。



---
## 数据结构
### 进程控制块结构
```C++
typedef struct Pcb {
	string name;		    // 进程名
	char state;		      // 运行状态(阻塞,就绪,运行,完成)
	string wait_reason;	// 等待原因(两个信号量)
	int breakp;			    // 断点
}Pcb, * Process;		  // 定义struct Pcb 为 Pcb,Pcb*为Process

```
- name
  - 进程名
  - 类型设置成string是因为可能有多个进程名,用字符串比较方便管理
    - 虽然这里只有两个进程,完全可以定义为char类型,但是为了情况的普适性而选择了string
- state  
  运行状态
  - 阻塞(B)
  - 就绪(W)
  - 运行(R)
  - 完成(C)
    
- block_reason
  - 题目中程序阻塞的原因只有一个,那就是信号量与零的关系,所以可以设置成char类型
  - s表示题设中的等待信号量s的状态
  - p(positive)表示s > 0
  - n(negative)表示s < 0
  - m表示s <= 0
- breakp;			
  - 断点保护 
  - int类型

---
### 生产者进程
#### 进程

#### 结点
- P操作
  - 申请一份资源
    - 能就绪就就绪
    - 不能就绪就阻塞
  - 加入到生产者列表中
    - 这部分函数在生产者列表中定义
      - 因为无法从进程获取到进程列表
#### 列表
- 插入结点
  - 将一个生产者结点加入到列表中



---
## 随笔
### Sleep函数
- [原文链接](https://www.cnblogs.com/ruiy/p/9699819.html)
- 功 能  
  执行挂起一段时间
---
#### 用 法  
  ```C++
  unsigned sleep(unsigned seconds);
  ```
- Sleep函数的一般形式:  
  ```C++
  Sleep(unisgned long);
  ```
  - Sleep()里面的单位，是以毫秒为单位
    - 所以如果想让函数滞留1秒的话，应该是Sleep(1000);
    - 在Linux下，sleep中的“s”不大写
      - sleep()里面的单位是秒，而不是毫秒。

---
#### 示例
- 示例
  ```C++
  #include <windows.h>
  int main(){
    int a;
    a=1000;
    Sleep(a);/* VC 使用Sleep*/
    return 0;
  }
  ```
- 应用程序
  ```C++
  #include <syswait.h>
  usleep(n) //n微秒
  Sleep（n）//n毫秒
  sleep（n）//n秒
  ```
- 驱动程序
  ```C++
  #include <linux/delay.h>
  mdelay(n) //milliseconds 其实现
  #ifdef notdef
  #define mdelay(n) (\
  {unsigned long msec=(n); while (msec--) udelay(1000);})
  #else
  #define mdelay(n) (\
  (__builtin_constant_p(n) && (n)<=MAX_UDELAY_MS) ? udelay((n)*1000) : \
  ({unsigned long msec=(n); while (msec--) udelay(1000);}))
  #endif
  ```
  - 调用asm/delay.h的udelay,udelay应该是纳秒级的延时
- Dos
  ```C++
  sleep(1); //停留1秒 
  delay(100); //停留100毫秒   
  ```
- Windows: 
  ```C++
  Sleep(100); //停留100毫秒 
  ```
- Linux 
  ```C++
  sleep(1);     //停留1秒 
  usleep(1000); //停留1毫秒 
  ```
- 每一个平台不太一样,最好自己定义一套跨平台的宏进行控制 

---
#### 注意
- 头文件
  - 在VC中使用带上头文件
      ```C++
      #include <windows.h>
      ```
  - 在gcc编译器中，使用的头文件因gcc版本的不同而不同
  - linux系统需要添加的头文件　　
      ```C++
      #include <unistd.h>
      ```
  - linux下，用g++编译，得添加unistd.h头文件，gcc则加不加都可以，因为标准C中有sleep文件了。
- 书写
  - 在VC中Sleep中的第一个英文字符为大写的"S"
  - 在标准C中是sleep, 不要大写.. 
    - 下面使用大写的来说明,, 具体用什么看你用什么编译器. 
    - 简单的说VC用Sleep, 别的一律使用sleep.

---
#### 秒还是微秒？关于延时函数sleep()
- 因为要写一段代码，需要用到sleep（）函数，在我印象中，sleep(10)好像是休眠10微秒，结果却是休眠了10秒（在Linux下）。觉得很奇怪，因为头儿也记得好像是微秒为单位的。所以就查了一下。
  - 原来linux下的sleep函数原型为：
    ```C++
    unsigned int sleep(unsigned int seconds);
    ```
    - 而MFC中的Sleep函数原型为：
      ```C++
      void Sleep(DWORD dwMilliseconds);
      ```
  - 也就是说，Linux下（使用的gcc的库），sleep()函数是以秒为单位的
    - sleep(1);就是休眠1秒。
      - 而MFC下的sleep()函数是以微秒为单位的
        - sleep(1000);才是休眠1秒。
      - 原来如此啊。而如果在Linux下也用微妙为单位休眠，可以使用线程休眠函数:
        ```C++
        void usleep(unsigned long usec);
        ```
        当然，使用的时候别忘记
        ```C++
        #include <system.h>
        ```
- 另外值得一提的是，linux下还有个delay()函数，原型为
  ```C++
  extern void delay(unsigned int msec);
  ```
  它可以延时msec*4毫秒
  - 也就是如果想延时一秒钟的话，可以这么用 delay(250);

---
### C++头文件
- 头文件中定义所有的类,结构体,函数
- 与头文件对应的源文件中定义要使用的变量以及头文件中所有类,结构体,函数的主体

---
### 进程控制块
- 进程控制块（Processing Control Block），是操作系统核心中一种数据结构，主要表示进程状态。

---
#### 作用
- 其作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位或与其它进程并发执行的进程。
  - 或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。
-  PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息，
- 它使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位或一个能与其他进程并发执行的进程。

---
### PV操作
- PV操作是一种实现进程互斥与同步的有效方法。
- PV操作与信号量的处理相关
  - P表示通过的意思(pass)
  - V表示释放的意思
- PV操作是典型的同步机制之一。
  - 用一个信号量与一个消息联系起来，
    - 当信号量的值为0时，表示期望的消息尚未产生；
    - 当信号量的值非0时，表示期望的消息已经存在。
  - 用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。
- P 操作：
  - 当信号量s的整型值大于0时，它表示某类公用资源的可用数。因此，每执行一次P操作就意味着请求分配一个单位的该类资源给执行P操作的进程使用，信号量s的整型值应减去1。
  - 当信号量s的整型值小于等于0时，表示已经没有此类资源可供分配了，因此，请求资源的进程将被阻塞在相应的信号量s的等待队列中。此时，s的整型值的绝对值等于在该信号量上等待的进程数。 
- V 操作：
  - 执行一次V操作就意味着进程释放出一个单位的该类可用资源，故信号量s的整型值应增加1。
  - 若s的整型值还小于等于0，表示在信号量s的等待队列中有因请求该类资源而被阻塞的进程，因此，就把等待队列中的一个进程唤醒，使之转移到就绪队列中去。
  - **注意：唤醒的次序依系统而定。** 

---
### 结构体与结构体指针
- 结构体指针可用于在结构体数组间移动
  - 单个进程与进程数组的定义

---
### C++预定义
```C++
#define volume_buffer 10;	// 根据题设,缓冲区容量为10
```

---
### 整型数据转字符串
```C++
// 将int 转换成string
string itos(int i){
	stringstream s;
	s << i;
	return s.str();
}
```
- 或者
```C++
using namespace std;
to_string((i);  // i为int类型数据
```

---
### 内存的申请与释放
```C++
no malloc no free
no new no delete
```

---
### 生成随机种子
- [原文链接](https://blog.csdn.net/jx232515/article/details/51510336)
```C++
srand((unsigned)time(NULL))
```
- srand函数是随机数发生器的初始化函数。
  - 原型:
    ```C++
    void srand(unsigned seed);
    ```
- 用法:
  - 它初始化随机种子，会提供一个种子
    - 这个种子会对应一个随机数
    - 如果使用相同的种子后面的rand()函数会出现一样的随机数
      - 如: 
        ```C++
        srand(1); 
        ```
        - 直接使用1来初始化种子。
  - **为了防止随机数每次重复，常常使用系统时间来初始化**，即使用 `time`函数来获得系统时间，
    - `time`函数的返回值为:
      - 从 00:00:00 GMT, January 1, 1970 到现在所持续的秒数
    - 然后将time_t型数据转化为(unsigned)型再传给srand函数，即:
      ```C++
      srand((unsigned) time(&t)); 
      ```
    - 还有一个经常用法，不需要定义time_t型t变量,即: 
      ```C++
      srand((unsigned) time(NULL)); 
      ```
      - 直接传入一个空指针，因为你的程序中往往并不需要经过参数获得的数据。
- 生成一个[0,1]的随机数
  - 劣化了要求,产生[0,1)的随机数
    ```C++
    srand((unsigned)time(NULL));
    cout << rand() % 1000 / (double)1000 << endl;
    ```




---- 
- 计算机并不能产生真正的随机数，而是已经编写好的一些无规则排列的数字存储在电脑里，把这些数字划分为若干相等的N份，并为每份加上一个编号用srand()函数获取这个编号，然后rand()就按顺序获取这些数字;
  - **当srand()的参数值固定的时候，rand()获得的数也是固定的**，所以一般srand的参数用time(NULL)，因为系统的时间一直在变，所以rand()获得的数，也就一直在变，相当于是随机数了。
  - 只要用户或第三方不设置随机种子，那么在默认情况下随机种子来自系统时钟。
- 如果想在一个程序中生成随机数序列，需要至多在生成随机数之前设置一次随机种子。 
  - 即：只需在**主程序开始处**调用
    ```C++
    srand((unsigned)time(NULL)); 
    ```
    - 后面直接用rand就可以了。不要在for等循环放置`srand((unsigned)time(NULL));`
---
- 例子
  ```C++
  void test_rand(void)
      {
            unsigned long n;
            srand((unsigned)time(NULL));
            for(int i = 0; i < 100; i++)
            {
                  n = rand();
                  printf("d\n", n);
            }
  }
  ```


# 第2次实验 处理器调度-时间片轮转法实现处理器调度



---
## 随笔
### 结构体与类
- [参考文章](https://www.cnblogs.com/starfire86/p/5367740.html)
- 最本质的一个区别就是默认的访问控制： 
  - 默认的继承访问权限
    - struct是public的，
    - class是private的。
  - 成员/数据默认访问控制:
    - struct作为数据结构的实现体，它默认的数据访问控制是public的，
    - class作为对象的实现体，它默认的成员变量访问控制是private的
  
### C4996错误
- 使用了弃用的库/函数


---
# 第3次实验 虚拟存储器

---
## 一、实验内容
- 模拟分页式虚拟存储管理中硬件的地址转换和缺页中断
- 选择页面调度算法处理缺页中断。

---
## 二、实验目的
- 在计算机系统中，为了提高主存利用率，往往把辅助存储器（如磁盘）作为主存储器的扩充，使多道运行的作业的全部逻辑地址空间总和可以超出主存的绝对地址空间。
  - 用这种办法扩充的主存储器称为虚拟存储器。
- 通过本实验帮助同学理解在分页式存储管理中怎样实现虚拟存储器

---
## 三、实验题目
- 本实验有三道题目，其中第一题必做，第二，三题中可任选一个。
  - 题目1:模拟分页式存储管理中硬件的地址转换和产生缺页中断。
  - 题目2:FIFO算法处理缺页中断

---
### 1.模拟硬件地址转换及缺页中断
- 第一题：模拟分页式存储管理中硬件的地址转换和产生缺页中断。

---
#### 提示
- 1.分页式虚拟存储系统是把作业信息的副本存放在磁盘上，当作业被选中时，可把作业的开始几页先装入主存且启动执行。
  - 为此，在为作业建立页表时，应说明
    - 哪些页已在主存
    - 哪些页尚未装入主存
  - 页表的格式为：
    | 页号 | 标志 | 主存块号 | 在磁盘上的位置 |
    | -    | -    | -       | -             | 
    |      |      |         |               |
    - 标志
      - 用来表示对应页是否已经装入主存
      - 标志位=1，则表示该页已经在主存
      - 标志位=0，则表示该页尚未装入主存。
    - 主存块号
      - 用来表示已经装入主存的页所占的块号。
    - 在磁盘上的位置
      - 用来指出作业副本的每一页被存放在磁盘上的位置。
---
- 2.作业执行时，指令中的逻辑地址指出了参加运算的操作存放的页号和单元号
  - 硬件的地址转换机构按页号查页表
    - 若该页对应标志为“1”，则表示该页已在主存，这时根据关系式：
      - $绝对地址=块号×块长+单元号$
    - 计算出欲访问的主存单元地址。
      - 如果块长为 2 的幂次，则可
        - 把块号作为高地址部分
        - 把单元号作为低地址部分
        - 上面两者拼接而成绝对地址。
      - 若访问的页对应标志为“0”，则
        - 表示该页不在主存
        - 这时硬件发“缺页中断”信号，有操作系统按该页在磁盘上的位置，把该页信息从磁盘读出装入主存后再重新执行这条指令
---
- 3.设计一个“地址转换”程序来模拟硬件的地址转换工作。
  - 当访问的页在主存时，则形成绝对地址，但不去模拟指令的执行，而用输出转换后的地址来代替一条指令的执行。
  - 当访问的页不在主存时，则输出“* 该页页号”，表示产生了一次缺页中断。
  - 该模拟程序的算法如图 3-1。
    ![图3-1](../res/img/OperatingSystem/实验3-虚拟存储器-图3-1地址转换模拟算法.png) 
---
- 4.假定主存的每块长度为 128 个字节；
  - 现有一个共七页的作业，其中第 0 页至第 3 页已经装入主存，其余三页尚未装入主存；
    - 该作业的页表为：  
      ![](../res/img/OperatingSystem/实验3-虚拟存储器-作业页表.png) 
    - 如果作业依次执行的指令序列为：  
      ![](../res/img/OperatingSystem/实验3-虚拟存储器-指令序列.png) 
---
- 5.运行设计的地址转换程序，显示或打印运行结果。
  - 因仅模拟地址转换，并不模拟指令的执行，故可不考虑上述指令序列中的操作。

---
### 2.FIFO算法处理缺页中断

---
#### 提示
- 1.在分页式虚拟存储系统中，当硬件发出“缺页中断”后，引出操作系统来处理这个中断事件。
  - 如果主存中已经没有空闲块，则可
    - 用 FIFO 页面调度算法把该作业中最先进入主存的一页调出，存放到磁盘上，
    - 然后再把当前要访问的页装入该块。
    > 调出和装入后都要修改页表页表中对应页的标志。

---
- 2.FIFO 页面调度算法总是淘汰该作业中最先进入主存的那一页,因此可以用一个数组来表示该作业已在主存的页面。假定作业被选中时，把开始的 m 个页面装入主存，则
  - 数组的元素可定为 m 个。例如：
    - $P[0]，P[1]，….，P[m-1]$
  - 其中每一个 $P[i]$（$i=0，1，….，m-1$）表示一个在主存中的页面号。它们的初值为：
    - $P[0]:=0，P[1]:=1，….，P[m-1]:=m-1$
  - 用一指针 k 指示当要装入新页时，应淘汰的页在数组中的位置，
    - k 的初值为“0”。
    - 当产生缺页中断后，操作系统选择 P[k]所指出的页面调出，然后执行：
      ```C++
      P[k]:=要装入页的页号
      k:=(k+1) mod m
      ```
    - 再由装入程序把要访问的一页信息装入到主存中。重新启动刚才那条指令执行。

---
- 3.编制一个 FIFO 页面调度程序，为了提高系统效率，
  - 如果应淘汰的页在执行中没有修改过，则可不必把该页调出（因在磁盘上已有副本）而直接装入一个新页将其覆盖。因此在页表中增加是否修改过的标志
    - 为“1”表示修改过
    - 为“0”表示未修改过
    - 格式为：
      | 页号 | 标志 | 主存块号 | 修改标志 | 在磁盘上的位置 |
      | -    | -    | -       | -       | -              |
      |      |      |         |         |                |
    - 由于是模拟调度算法，所以，不实际启动输出一页和装入一页的程序，而用输出调出的页号和装入的页号来代替一次调出和装入的过程。
    - 把第一题中程序稍作修改，与本题结合起来，FIFO 页面调度模拟算法如图 3-2。
      ![图3.2](../res/img/OperatingSystem/实验3-虚拟存储器-图3-2-FIFO页面调度模拟算法.png)

---
- 4.磁盘上，在磁盘上的存放地址以及已装入主存的页和作业依次执行的指令序列都同第一题中（4）所示。于是增加了“修改标志”后的初始页表为：
  ![](../res/img/OperatingSystem/实验3-虚拟存储器-题目2-增加了修改标志的初始页表.png)
  - 按依次执行的指令序列，运行你所设计的程序
    - 显示或打印每次调出和装入的页号，以及执行了最后一条指令后的数组 P 的值。

---
- 5.为了检查程序的正确性，可再任意确定一组指令序列，运行设计的程序，核对执行的结果。

---
## 随笔

---
### 定长字符串输出
```C++
// 头文件
#include<iomanip>
// 使用
cout<<setw(长度)<<"字符串";
```

---
### 左右对齐
```C++
cout << setiosflags(ios::left) <<....   // 左对齐
cout << setiosflags(ios::right) <<....  // 右对齐
```

---
### 字符串结束标志
- ‘\0'是转义字符，代表空字符，一般在字符串结尾作为字符串结束标志


---
### VS快速注释多行
- 选中后$Ctrl+K,Ctrl+C$
- 取消注释
  - 选中后$Ctrl+K,Ctrl+U$

---
### VS读取CSV文件
- [参考链接](https://blog.csdn.net/sinat_38792591/article/details/100190990)
```C++
	ifstream inFile("page.csv", ios::in);
	string lineStr;
	vector<vector<int>> intArray;
	while (getline(inFile, lineStr)) {
		// 存成二维表结构  
		stringstream ss(lineStr);
		string str;
		vector<int> lineArray;
		// 按照逗号分隔  
		while (getline(ss, str, ','))
			lineArray.push_back(stoi(str)); // stoi(str)把string转为int
		intArray.push_back(lineArray);
	}
```
- stoi(str)要求str必须可以转换为int,否则就会报错

---
# 第4次实验 驱动调度

---
## 实验内容
- 模拟电梯调度算法，实现对磁盘的驱动调度。

---
## 实验目的
- 磁盘是一种高速、大容量、旋转型、可直接存取的存储设备。它作为计算机系统的辅助存储器，担负着繁重的输入输出任务、在多道程序设计系统中，往往同时会有若干个要求访问磁盘的输入输出请求等待处理。系统可采用一种策略，尽可能按最佳次序执行要求访问磁盘的诸输入输出请求。这就叫驱动调度，使用的算法称为驱动调度算法。
- 驱动调度能降低为若干个输入输出请求服务所需的总时间，从而提高系统效率。
- 本实验要求学生模拟设计一个驱动调度程序，观察驱动调度程序的动态运行过程。通过实验使学生理解和掌握驱动调度的职能

---
## 实验题目
- 模拟电梯调度算法，对磁盘进行移臂和旋转调度。
- 提示：
  - (1).磁盘是可供多个进程共享的存储设备，但一个磁盘每时刻只能为一个进程服务。当有进程在访问某个磁盘时，其他想访问该磁盘的进程必须等待，直到磁盘一次工作结束。
    - 当有多个进程提出输入输出要求而处于等待状态时，可用电梯调度算法从若干个等待访问者中选择一个进程，让它访问磁盘。选择访问者的工作由“驱动调度”进程来完成。
    - 由于磁盘与处理器是可以并行工作的、所以当磁盘在作为一个进程服务时，占有处理器的另一进程可以提出使用磁盘的要求，也就是说，系统能动态地接收新的输入输出请求。为了模拟这种情况，在本实验中设置了一个“接收请求”进程。
    - “驱动调度”进程和“接收请求”进程能否占有处理器运行，取决于磁盘的结束中断信号和处理器调度策略。在实验中可用随机数来模拟确定这两个进程的运行顺序，以代替中断处理和处理器调度选择的过程。因而，程序的结构可参考图 4—1    
      ![图4-1](../res/img/OperatingSystem/实验4-驱动调度-图4-1-程序结构.png) 
  - (2).“接收请求”进程建立一张“请求 I/O”表，指出访问磁盘的进程要求访问的物理地址，表的格式.
    | 进程名 | 柱面号 | 磁道号 | 物理记录号 |
    | - | - | - |- |
    |   |   |   |   |
    - 假定某个磁盘组共有 200 个柱面，由外向里顺序编号（0—199），每个柱面上有 20 个磁道，编号为 0—19，每个磁道分成 8 个物理记录，编号 0—7。进程访问磁盘的物理地址可以用键盘输入的方法模拟得到。图 4—2 是“接收请求”进程的模拟算法  
      ![图4-2](../res/img/OperatingSystem/实验4-驱动调度-图4-2-接收请求模拟算法.png) 
    - 在实际的系统中必须把等待访问磁盘的进程排入等待列队，由于本实验模拟驱动调度，为简单起见，在实验中可免去队列管理部分，故设计程序时可不考虑“进程排入等待队列”的工作。
  - （3）“驱动调度”进程的功能是查“请求 I/O”表，当有等待访问磁盘的进程时，按电梯调度算法从中选择一个等待访问者，按该进程指定的磁盘物理地址启动磁盘为其服务。
    - 对移动臂磁盘来说，驱动调度分移臂调度和旋转调度。电梯调度算法的调度策略是与移动臂的移动方向和移动臂的当前位子有关的，所以每次启动磁盘时都应登记移动臂方向和当前位子。
    - 电梯调度算法是一种简单而实用的驱动调度方法，这种调度策略总是优先选择与当前柱面号相同的访问请求，从这些请求中再选择一个能使旋转距离最短的等待访问者。
      - 如果没有与当前柱面号相同的访问请求，则根据移臂方向来选择，每次总是沿臂移动方向选择一个与当前柱面号最近的访问请求，若沿这个方向没有访问请求时，就改变臂的移动方向。
    - 这种调度策略能使移动臂的移动频率极小，从而提高系统效率。用电梯调度算法实现驱动调度的模拟算法如图 4－3。
  - (4).
    - `图 4－1`中的初始化工作包括
      - 初始化“请求 I/O”表，置当前移臂方向为里移；
      - 置当前位置为 0 号柱面，0 号物理记录。
      - 程序运行前可假定“请求 I/O”表中已经有如干个进程等待访问磁盘。
    - 在模拟实验中，当选中一个进程可以访问磁盘时，并不实际地启动磁盘，而用显示：
      - “请求 I/O”表；当前移臂方向；当前柱面号，物理记录号
      - 来代替`图 4－3` 中的“启动磁盘”这项工作   
    
  ![](../res/img/OperatingSystem/实验4-驱动调度-图4-3-电梯调度模拟算法.png) 

---
## 实验报告
- （1）实验题目。
- （2）程序中使用的数据结构及其说明。
- （3）打印一份源程序并附上注释。
- （4）打印驱动调度进程每次选择访问请求前的“请求 I/O”表以及每次选中的进程名、访问的柱面号、物理记录号和当前移臂方向（用 up 代表里移，down 代表外移。打印格式为：  
  ![](../res/img/OperatingSystem/实验4-打印格式.png)


---
## 随笔

---
### `system("cls")`
- DOS窗口清屏