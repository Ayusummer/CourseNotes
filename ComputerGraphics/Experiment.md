# 实验1-二维图形绘制

---
## 实验内容

---
### 1.绘制金刚石图案​
- 金刚石图案的成图规则是：把一个圆周等分成​n份，然后每两点之间连线。当n取奇数时，该图案可一笔连续绘成，即用MoveTo函数确定一个当前点，然后连续用LineTo函数连点成线。​
- 请设计连线规则并编程实现。​

----
### 2.绘制魔术三角形
- 绘制下图所示的魔术三角形图案 ，采用三种可明显区分的颜色填充。  
  ![20210521221041](http:cdn.ayusummer233.top/img/20210521221041.png)


----
### 3.绘制递归圆​
- 应用递归的方法绘制如下所示的图案。  
  ![20210521221151](http:cdn.ayusummer233.top/img/20210521221151.png)  
  


---
## 实验环境
> 本次上机实验所使用的平台和相关软件。
- win10专业版
- IDE选择 : Pycharm
- python版本 : python3.8.5
- 导入第三方库版本:


----
## 问题分析
> 对所要解决的问题进行阐述和分析，提出解决方法，列出解决步骤。

---
### 绘制金刚石图案
- 金刚石图案的成图规则是：把一个圆周等分成​n份，然后每两点之间连线。当n取奇数时，该图案可一笔连续绘成，即用MoveTo函数确定一个当前点，然后连续用LineTo函数连点成线。​
- 请设计连线规则并编程实现。​



----
## 算法设计
> 用流程图或伪代码描述解决问题的算法。



----
## 源代码


----
## 程序运行结果


----
## 总结

### python绘制金刚石
```python
import turtle
import math
import time


def draw(x, y, r):
    turtle.penup()
    turtle.goto(x, y)
    turtle.pendown()
    turtle.circle(r)


def join(x, y, ex, ey):
    turtle.penup()
    turtle.goto(x, y)
    turtle.pendown()
    turtle.goto(ex, ey)


if __name__ == '__main__':
    rid = int(turtle.textinput('输入', '输入半径'))

    turtle.setup(width=1000, height=1000)
    turtle.speed(50)
    # draw(0,0,300)
    xlist = []
    ylist = []

    for i in range(0, 30):
        xlist.append(rid * math.cos(math.pi / 15 * i));
        ylist.append(rid * math.sin(math.pi / 15 * i));
        # print(12*i,' R == ',i*15);
        draw(0, (i + 1) * -(rid / 30), (i + 1) * (rid / 30));
    for i in range(0, xlist.__len__()):
        for j in range(0, xlist.__len__()):
            join(xlist[i], ylist[i], xlist[j], ylist[j])
```
---
#### turtle

---
##### turtle.speed(speed=None)
- `speed` : 一个 [0,10] 范围内的整型数或速度字符串
  - `fastest`: 0 最快
  - `fast`: 10 快
  - `normal`: 6 正常
  - `slow`: 3 慢
  - `slowest`: 1 最慢

---
##### turtle.circle(radius, extent=None, steps=None)
- `radius` : 一个数值
- `extent` : 一个数值 (或 None)
- `steps` : 一个整型数 (或 None)
    
    ---
- 绘制一个 radius 指定半径的圆。圆心在海龟左边 radius 个单位；extent 为一个夹角，用来决定绘制圆的一部分。如未指定 extent*则绘制整个圆。如果 *extent 不是完整圆周，则以当前画笔位置为一个端点绘制圆弧。如果 radius 为正值则朝逆时针方向绘制圆弧，否则朝顺时针方向。最终海龟的朝向会依据 extent 的值而改变。
- 圆实际是以其内切正多边形来近似表示的，其边的数量由 steps 指定。如果未指定边数则会自动确定。此方法也可用来绘制正多边形。
> - 要注意的是,画笔起始点位置并非圆心,而是圆心垂线与下圆弧的交点
>   ![](https://cdn.ayusummer233.top/image/c4x4voXmXM.gif)


---
## debug

---
### 未找到`graphics.h`
- 原因在于缺少EasyX支持,该库需要手动安装
  - [EasyX官网](https://easyx.cn/easyx)
  - [适用于VS2019的版本]()
- 下载之后运行安装即可
  ![20210409182232](http:cdn.ayusummer233.top/img/20210409182232.png)
- [官中文档](https://docs.easyx.cn/zh-cn/device-func)
  - [离线版](https://ayusummer-my.sharepoint.com/:u:/g/personal/233_ayusummer_onmicrosoft_com/EZU2zHoF049HhFajv8Cyx_ABkPKQli9uYtn__fOdWMkN6A?e=eDekIl)
---



  
----
# 实验2-曲线拟合

---
## 实验内容


---
## 实验环境


----
## 问题分析


----
## 算法设计


----
## 源代码


----
## 程序运行结果


----
## 总结




---
## 实验要求
- 1.绘制三次Bezier曲线
  - 1.给定四个已知点P1—P4，以此作为控制顶点绘制一段三次Bezier曲线。
  - 2.给定四个已知点P1—P4，以此作为曲线上的点绘制一段三次Bezier曲线。
- 2.绘制三次B样条曲线
  - 给定六个已知点P1—P6，以此作为控制顶点绘制一条三次B样条曲线。

----
### 相关概念

---
#### Bezier曲线
- Bezier曲线通过一组多边折线的各顶点唯一的定义出来。​
  - 在多边折线的各顶点中，只有`第一点和最后一点在曲线上`，其余的顶点则用来定义曲线的导数，阶次和形状。`第一条边和最后一条边分别和曲线在起点和终点处相切`，曲线的形状趋于多边折线的形状，改变多边折线的顶点位置和曲线形状的变化有着直观的联系。多边折线称为`特征多边形`，其顶点称为`控制点`。​


----
#### B样条曲线
- B样条曲线是Bezier曲线的拓广，它是用B样条基函数代替了Bezier曲线表达式中的Bernstain基函数。​


## debug

### python安装OpenGL
```
pip install pyopengl
```


-----
# 实验3-二维图形变换

---
## 实验内容


---
## 实验环境


----
## 问题分析


----
## 算法设计


----
## 源代码


----
## 程序运行结果


----
## 总结





----
## 绘制北极星图案






----
# 实验4-线段裁剪

---
## 实验内容
- 采用Ivan Sutherland算法（编码裁剪算法）实现二维线段的裁剪，要求：以金刚石图案中圆周的最上点和最右点构成的窗口对该图案进行裁剪。 ​
- ![20210520222651](http:cdn.ayusummer233.top/img/20210520222651.png)

---
## 实验环境
> 本次上机实验所使用的平台和相关软件。
- win10专业版
- IDE选择 : Pycharm
- python版本 : python3.8.5
- 导入第三方库版本:





----
## 问题分析
> 对所要解决的问题进行阐述和分析，提出解决方法，列出解决步骤。

---
### Ivan Sutherland算法(编码裁剪法)
- Ivan Sutherland算法也称Sutherland-Cohen算法。
- 其核心思想是：分区编码和线段分割。
  - `分区编码方法` ：以$x=x_L、x=x_R、y=y_T、y=y_B$将图形区域划分成九个部分。采用四位编码表示端点所处的位置：    
    ![20210521082025](http:cdn.ayusummer233.top/img/20210521082025.png)
    - 第一位为“1”时，表示点在y=yT的上方；
    - 第二位为“1”时，表示点在y=yB的下方；
    - 第三位为“1”时，表示点在x=xR的右方；
    - 第四位为“1”时，表示点在x=xL的左方。

  ---
#### 算法思想
- 1.确定线段的两个端点$P_1$和$P_2$的代码值$C_1$和$C_2$（经一系列的判断 —— $p_1(x1, y1), p_2(x_2, y_2)$和$x_R、x_L、y_T、y_B$的比较，分别给代码中的各位赋值）。
- 2.对线段的端点进行检测
  - 若线段全部在窗口外 ( `c1 & c2 != 0` ) —— 退出
  - 若线段全部在窗口内 ( `c1 == 0 && c2 == 0` ) —— 画线
  - 否则($c1≠0 or c2≠0 且 c1  and  c2 = 0$)要对线段进行分割，关键是求与窗口四边的交点( 利用直线的两点式方程 )。交点求出后，要对其重新编码，并继续判断。
> 一个点的代码的某位为 1 表示该点在矩形框的某一边框 **外侧** , 如果两个点都在矩形框的某条边的外侧,那么这两点连线在矩形框外侧, 也就是说两个代码只要有一位同为1那么就表明两点连线在矩形框外侧,也即 `c1 & c2 != 0`

  ---
- 例图   
  ![20210521082829](http:cdn.ayusummer233.top/img/20210521082829.png)


----
## 算法设计
> 用流程图或伪代码描述解决问题的算法。

- `Sutherland-Cohen`算法流程图     
  ![20210521082903](http:cdn.ayusummer233.top/img/20210521082903.png)

------
- 但是注意到实验题目是对于一个二维`图案`的裁剪,也就是说需要有一个函数是对于一个庞大的二维点集中的部分点进行裁剪; 相应的也就要求该函数的参数除了裁剪的矩形区域的确定之外还需要有一个图案点集的参数
  - 这个函数内部会重复调用裁剪线段的函数;
    - 这样引起的问题在于如何通过点集获取这些需要裁剪的线段
> 感觉函数复杂度不低,不知道实际操作中直接用一个遮罩盖住该区域是否会更有效些

-----
### 二维图案裁剪



---
### `Sutherland-Cohen`算法裁剪二维线段




----
- 需要先取消掉需要裁剪线段的显示,然后裁剪完再重新绘制



----
## 源代码


----
## 程序运行结果


----
## 总结 