<!--
 * @Author: 咸鱼型233
 * @Date: 2021-06-07 13:25:57
 * @LastEditTime: 2021-06-07 16:55:45
 * @LastEditors: Please set LastEditors
 * @Description: 图形学考前复习
 * @FilePath: \JuniorLesson_SecondTerm\ComputerGraphics\Review.md
    -->



------

# 目录

- [目录](#目录)
- [中点画线算法](#中点画线算法)
  - [DDA 算法](#dda-算法)
  - [中点画线算法](#中点画线算法-1)
    - [实现整数运算](#实现整数运算)
    - [算法书写示例](#算法书写示例)
    - [例题 : 用中点画线算法绘制 $P_0 (0, 0) -> P_1 (5, 2)$](#例题--用中点画线算法绘制-p_0-0-0---p_1-5-2)



---

# 中点画线算法
- 先考算法描述然后再举个例子

    ----
- 首先要明白中点画线算法是一种直线的生成算法,而说到直线的生成算法那么首先要提一下生成直线的 DDA(Digital Differential Analyzer) 算法(又称数值微分法)

    ---
## DDA 算法
- DDA算法是计算机图形学中最简单的绘制直线算法。其主要思想是由直线公式 $y = kx + b$ 推导出来的。我们已知直线段两个端点 $P0(x0,y0)$ 和 $P1(x1,y1)$，就能求出 $k$ 和 $b$ 
  
    ---
-  无论是显示器还是绘图机，都可以看成有一个网格(离散单元组成的矩阵)存在，对显示器来说每一个像素就是一个网格点，对绘图机来说笔每走一步的终点也可以看成是一个网格的结点。
- 在显示器上表示一条直线, 就是要用最靠近直线的一些网格点来代表这一直线。这个网格就构成屏幕和绘图机纸张的一个坐标系，相邻两个网点的距离取为1，每个网格点的坐标均取整数。    

  ![20210607134530](http://cdn.ayusummer233.top/img/20210607134530.png)

- 假设直线的起点坐标为 $P1 (x1,y1)$. 终点坐标为 $P2 (x2,y2)$, x 方向的增量为 $△x＝x2－x1$; y方向上增量为 $△y＝y2－y1$  
   那么直线的斜率 $k＝△y／△x$    
   当 $△x＞△y$ 时，让 x 从 x1 到 x2 变化，每步递增 1   
   那么 x 的变化可以表示为 $x_{i+1}＝xi＋1$    
   y 的变化可以表示为 $y_{i+1}＝yi＋k$
- 用上式可求得图中直线 P1P2 和 y 方向网格线的交点，但显示时要用象素点(图中的网格结点)耒表示，所以要用舍入的办法耒找到最靠近交点处的象素点，并用其耒表示直线段。
- 这个方法称之为数字微分分析法，简称DDA。

    ---
  ![20210607135102](http://cdn.ayusummer233.top/img/20210607135102.png)    
  `int(x)` 会把 x 的小数部分去掉保留整数部分, `int(x+0.5)` 可以用来四舍五入
- 算法描述如下：
  ```C++
  int  x1, y1, x2, y2;
  int  x;
  double dx, dy, k, y;
  dx ＝ x2 - x1;
  dy ＝ y2 - y1;
  k ＝ dy / dx;
  x ＝ x1;
  y ＝ y1;
  if(abs(k) < 1)
    for( ; x＜＝x2; x++){ 
        putpixel(x, (int)(y+0.5), pixelcolor);
        y＝y＋k;
    }
  else
    for( ; y＜＝y2; y++){ 
    putpixel((int)(x+0.5), y, pixelcolor);
    x ＝ x ＋ 1/k;
    }
  ```
  - 最后的 `if-else` 逻辑要将变化幅度小的一方作为度量, 这样可以画更多点使得曲线更准确

    ---
## 中点画线算法
- 采用增量思想的 DDA 算法, 每计算一个象素只需计算一个加法，是否最优？
  - 不是,因为算法里含有浮点数运算
  
- `目标` : 进一步将一个加法改为一个整数加法。

- DDA 算法采用直线的点斜式方程, 中点画线算法采用直线的隐式方程

- 设直线段的起点和终点分别为: $(x0, y0), (x1,y1)$  
   $F(x,y)=ax+by+c=0$     
   $a=y0-y1$  
   $b=x1-x0$    
   $c=x0y1-x1y0$     
   均为整数
   
-  `基本思想` : 设当前象素点为 $(xp, yp)$ ，下一个象素点为 P1 或 P2       
  设 $M=(xp+1, yp+0.5)$即为 $p1$ 与 $p2$ 的中点，Q 为实际直线与 $x=xp+1$ 的交点。将 Q 与 M 的 y 坐标进行比较。   

  - 若 M 在 Q 的下方，应取 P2 为下一点
  - 若 M 在 Q 的上方，应取 P1 为下一点
  
    ![image-20210607155126647](http://cdn.ayusummer233.top/img/image-20210607155126647.png)

- 直线的正负划分性

  - 直线上方点 : $F(x,y)＞0$

  - 直线下方的点 : $F(x,y)＜0$

    ![image-20210607162025808](http://cdn.ayusummer233.top/img/image-20210607162025808.png)



-----

- 构造判别式 : $d=F(M)=F(xp+1,yp+0.5) \\ =a(xp+1)+b(yp+0.5)+c$

  其中 $a=y0-y1, b=x1-x0, c=x0y1-x1y0$

  - 若 d < 0 : M 在直线( Q 点)下方，取右上方 P2 为下一个象素
  - 若 d > 0 : M 在直线( Q 点)上方，取右方 P1 为下一个象素
  - 若 d == 0 : 选 P1 或 P2 均可，约定取 P1 为下一个象素

  ![image-20210607162159336](http://cdn.ayusummer233.top/img/image-20210607162159336.png)

  - 增量算法

    - 若当前象素处于 $d >= 0$ 情况，则取正右方象素 $P1 (xp+1, yp)$,  要判下一个象素位置，应计算

      $d1=F(xp+2, yp+0.5)=a(xp+2)+b(yp+0.5)+c=d+a$    -> 增量 delta1 为 a  

    - d < 0 时, 则取右上方象素 $P2 (xp+1, yp+1)$, 要判断再下一象素，则要计算

      $d2= F(xp+2, yp+1.5)=a(xp+2)+b(yp+1.5)+c=d+a+b$  ->  增量 delta2 为 a+b   

### 实现整数运算

- 画线从起点 $(x0, y0)$ 开始, d 的初值

  $d0=F(x0+1, y0+0.5)=F(x0, y0)+a+0.5b =a+0.5b$

  - 解决方法 : 2d 代替 d, 则

    $d0=2d0=2a+b$

    $d1=2d1=2d+2a$  ->  增量 delta1 = 2a

    $d2=2d2=2d+2a+2b$  ->  增量 delta2 = 2a+2b

  > PS : 别把 d 和 y 弄混了, d 是用来判断 "中点" 和直线的位置关系的, 将 d 换成 2d 并不会影响 "中点" 与直线的位置关系
  >
  > ​        y 是直线上的点

  

### 算法书写示例

```C++
void Midpoint Line (int x0, int y0, int x1, int y1, int color){   
    int a, b, delta1, delta2, d, x, y;
    a = y0-y1, b = x1-x0, d = 2*a+b;
    delta1 = 2*a, delta2 = 2*(a+b);
    x = x0, y = y0;
    putpixel(x, y, color);
    while(x < x1){ 
        if (d<0){x++, y++, d += delta2;}    // 选择右上方象素
        else    {x++, d += delta1;}		 // 选择正右方象素
        putpixel(x, y, color);
     }  /* while */
 } /* mid PointLine */

```

-----

### 例题 : 用中点画线算法绘制 $P_0 (0, 0) -> P_1 (5, 2)$

![image-20210607165244633](http://cdn.ayusummer233.top/img/image-20210607165244633.png)

------

