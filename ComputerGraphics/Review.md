<!--

 * @Author: 咸鱼型233
 * @Date: 2021-06-07 13:25:57
 * @LastEditTime: 2021-06-09 12:31:11
 * @LastEditors: Please set LastEditors
 * @Description: 图形学考前复习
 * @FilePath: \JuniorLesson_SecondTerm\ComputerGraphics\Review.md
    -->



------

# 目录

- [目录](#目录)
- [论述与应用题的考点详情](#论述与应用题的考点详情)
- [中点画线算法](#中点画线算法)
  - [DDA 算法](#dda-算法)
  - [中点画线算法](#中点画线算法-1)
    - [实现整数运算](#实现整数运算)
    - [算法书写示例](#算法书写示例)
    - [例题 : 用中点画线算法绘制 $P_0 (0, 0) -> P_1 (5, 2)$](#例题--用中点画线算法绘制-p_0-0-0---p_1-5-2)
- [Bresenham 画圆算法](#bresenham-画圆算法)
  - [算法描述](#算法描述)
- [自由曲线绘制方法 & Bezier 样条曲线](#自由曲线绘制方法--bezier-样条曲线)
  - [简述自由曲线绘制方法](#简述自由曲线绘制方法)
  - [举例绘制 Bezier 样条曲线](#举例绘制-bezier-样条曲线)
    - [实验代码](#实验代码)
    - [三次 Bezier 曲线](#三次-bezier-曲线)
    - [Bezier 曲线](#bezier-曲线)
    - [二次 Bezier 曲线](#二次-bezier-曲线)
- [区域填充](#区域填充)
- [三维图形几何变换](#三维图形几何变换)
- [编码裁剪算法](#编码裁剪算法)
- [八叉树表示法](#八叉树表示法)
- [透视投影 & 观察空间的定义](#透视投影--观察空间的定义)
- [扫描线消隐算法](#扫描线消隐算法)
- [多边形明暗处理](#多边形明暗处理)



---

# 论述与应用题的考点详情

> 这些考点也同样会考选择填空题

- 中点画线算法

  先考算法描述再举一个例子, 用这个方法把构成这条曲线的像素点算出来

- Bresenham 画圆算法

  算法描述, 上课讲了第一象限的绘制方法, 要求绘制完整的圆(超星视频里有,补三条语句即可)

- 自由曲线绘制算法 & Bezier 样条曲线绘制方法

  简述自由曲线绘制方法:

  - 自由曲线是没有一个明确的参数方程对整条曲线进行描述的一类曲线, 所以对于自由曲线的绘制要转换成样条曲线来进行绘制;
  - 对于样条曲线而言, 它是规则的曲线, 有明确的参数方程; 所以我们利用样条曲线的参数方程, 让参变量 t = 0 开始以一定步长递增到 1 为止把样条曲线上的点计算出来, 然后相邻的点用小直线段连接, 把这样一段样条曲线绘制出来, 当自由曲线分解得到的样条曲线均绘制完成时就完成了对整条自由曲线的绘制

  举例绘制 Bezier 样条曲线(实验做过)

- 区域填充

  与中点画线算法的考法类似, 首先请大家描述一下区域填充的算法, 然后给出一个例子, 根据算法把给出的区域填充好(要知道填充的时候不同位置处填充的先后次序)(看看给的例子里所涉及的区域当中的像素点和填充次序是怎样的)

- 三维图形几何变换

  考察几何变换的方法, 会给出具体的示例, 让大家求这个变换中的变换矩阵

  肯定考得是复杂几何变换, 要分解成基本几何变换, 要求的矩阵就是所涉及的基本变换矩阵的乘积

- 编码裁剪算法

  也与中点画线算法的考法一致, 首先描述一遍编码裁剪算法;

  然后会给出一个具体的实例,  用编码裁剪算法把例子中的线段进行裁剪: 要求描述裁剪过程, 不能只是直接把最后裁剪出的线段画出来

  > 凡是涉及到算法应用的, 都是要把中间过程一步一步的结果写出来的, 中间结果一定要完整

- 八叉树表示法

  对于三维形体采用八叉树表示法进行描述的话. 表示的基本原理和过程是怎样的(上课讲过, 看下超星视频)

  八叉树表示法的缺点和对应改善方法(看下超星视频)

- 透视投影 & 观察空间的定义

  放在一起考

  描述透视投影的观察空间的定义的方法

  观察空间的定义包括两个步骤

  ​	    观察坐标系的定义

  ​        在观察坐标系的基础上定义观察空间

  > 一定要先写观察坐标系的定义再写观察空间的定义

  把当时讲过的定义观察空间的那些参数的缺省取值, 在缺省取值情况下透视投影的观察空间是什么样子的,怎么画出来的

- 扫描线消隐算法

  描述一下扫描线消隐算法的算法步骤

  然后回答一下为了提高扫描线消隐算法的效率需要解决什么问题, 怎么解决

  ​        要解决 4 个问题, 前 3 个问题用数据结构解决, 第 4 个问题使用相关性解决

  > 要写清楚写具体每一个问题是用什么解决的

- 多边形明暗处理

  描述一下多边形明暗处理的背景方法, 具体的过程

  > 思想,步骤,公式......... 

---

# 中点画线算法

- 先考算法描述然后再举个例子

    ----
- 首先要明白中点画线算法是一种直线的生成算法,而说到直线的生成算法那么首先要提一下生成直线的 DDA(Digital Differential Analyzer) 算法(又称数值微分法)

    ---
## DDA 算法
- DDA算法是计算机图形学中最简单的绘制直线算法。其主要思想是由直线公式 $y = kx + b$ 推导出来的。我们已知直线段两个端点 $P0(x0,y0)$ 和 $P1(x1,y1)$，就能求出 $k$ 和 $b$ 
  
    ---
-  无论是显示器还是绘图机，都可以看成有一个网格(离散单元组成的矩阵)存在，对显示器来说每一个像素就是一个网格点，对绘图机来说笔每走一步的终点也可以看成是一个网格的结点。
- 在显示器上表示一条直线, 就是要用最靠近直线的一些网格点来代表这一直线。这个网格就构成屏幕和绘图机纸张的一个坐标系，相邻两个网点的距离取为1，每个网格点的坐标均取整数。    

  ![20210607134530](http://cdn.ayusummer233.top/img/20210607134530.png)

- 假设直线的起点坐标为 $P1 (x1,y1)$. 终点坐标为 $P2 (x2,y2)$, x 方向的增量为 $△x＝x2-x1$; y方向上增量为 $△y＝y2-y1$  
   那么直线的斜率 $k＝△y／△x$    
   当 $△x＞△y$ 时，让 x 从 x1 到 x2 变化，每步递增 1   
   那么 x 的变化可以表示为 $x_{i+1}＝xi+1$    
   y 的变化可以表示为 $y_{i+1}＝yi+k$
- 用上式可求得图中直线 P1P2 和 y 方向网格线的交点，但显示时要用象素点(图中的网格结点)耒表示，所以要用舍入的办法耒找到最靠近交点处的象素点，并用其耒表示直线段。
- 这个方法称之为数字微分分析法，简称DDA。

    ---
  ![20210607135102](http://cdn.ayusummer233.top/img/20210607135102.png)    
  `int(x)` 会把 x 的小数部分去掉保留整数部分, `int(x+0.5)` 可以用来四舍五入
- 算法描述如下:
  ```C++
  int  x1, y1, x2, y2;
  int  x;
  double dx, dy, k, y;
  dx ＝ x2 - x1;
  dy ＝ y2 - y1;
  k ＝ dy / dx;
  x ＝ x1;
  y ＝ y1;
  if(abs(k) < 1)
    for( ; x＜＝x2; x++){ 
        putpixel(x, (int)(y+0.5), pixelcolor);
        y＝y+k;
    }
  else
    for( ; y＜＝y2; y++){ 
    putpixel((int)(x+0.5), y, pixelcolor);
    x ＝ x + 1/k;
    }
  ```
  - 最后的 `if-else` 逻辑要将变化幅度小的一方作为度量, 这样可以画更多点使得曲线更准确

    ---
    
    

<div STYLE="page-break-after: always;"></div>
<!--这里有个分页符-->




## 中点画线算法

- 采用增量思想的 DDA 算法, 每计算一个象素只需计算一个加法，是否最优？
  - 不是,因为算法里含有浮点数运算
  
- `目标` : 进一步将一个加法改为一个整数加法。

- DDA 算法采用直线的点斜式方程, 中点画线算法采用直线的隐式方程

- 设直线段的起点和终点分别为: $(x0, y0), (x1,y1)$  
   $F(x,y)=ax+by+c=0$     
   $a=y0-y1$  
   $b=x1-x0$    
   $c=x0y1-x1y0$     
   均为整数
   
-  `基本思想` : 设当前象素点为 $(xp, yp)$ ，下一个象素点为 P1 或 P2       
  设 $M=(xp+1, yp+0.5)$即为 $p1$ 与 $p2$ 的中点，Q 为实际直线与 $x=xp+1$ 的交点。将 Q 与 M 的 y 坐标进行比较。   

  - 若 M 在 Q 的下方，应取 P2 为下一点
  - 若 M 在 Q 的上方，应取 P1 为下一点
  
    ![image-20210607155126647](http://cdn.ayusummer233.top/img/image-20210607155126647.png)

- 直线的正负划分性

  - 直线上方点 : $F(x,y)＞0$

  - 直线下方的点 : $F(x,y)＜0$

    ![image-20210607162025808](http://cdn.ayusummer233.top/img/image-20210607162025808.png)



-----

- 构造判别式 : $d=F(M)=F(xp+1,yp+0.5) \\ =a(xp+1)+b(yp+0.5)+c$

  其中 $a=y0-y1, b=x1-x0, c=x0y1-x1y0$

  - 若 d < 0 : M 在直线( Q 点)下方，取右上方 P2 为下一个象素
  - 若 d > 0 : M 在直线( Q 点)上方，取右方 P1 为下一个象素
  - 若 d == 0 : 选 P1 或 P2 均可，约定取 P1 为下一个象素

  ![image-20210607162159336](http://cdn.ayusummer233.top/img/image-20210607162159336.png)

  - 增量算法

    - 若当前象素处于 $d >= 0$ 情况，则取正右方象素 $P1 (xp+1, yp)$,  要判下一个象素位置，应计算

      $d1=F(xp+2, yp+0.5)=a(xp+2)+b(yp+0.5)+c=d+a$    -> 增量 delta1 为 a  

    - d < 0 时, 则取右上方象素 $P2 (xp+1, yp+1)$, 要判断再下一象素，则要计算

      $d2= F(xp+2, yp+1.5)=a(xp+2)+b(yp+1.5)+c=d+a+b$  ->  增量 delta2 为 a+b   

### 实现整数运算

- 画线从起点 $(x0, y0)$ 开始, d 的初值

  $d0=F(x0+1, y0+0.5)=F(x0, y0)+a+0.5b =a+0.5b$

  - 解决方法 : 2d 代替 d, 则

    $d0=2d0=2a+b$

    $d1=2d1=2d+2a$  ->  增量 delta1 = 2a

    $d2=2d2=2d+2a+2b$  ->  增量 delta2 = 2a+2b

  > PS : 别把 d 和 y 弄混了, d 是用来判断 "中点" 和直线的位置关系的, 将 d 换成 2d 并不会影响 "中点" 与直线的位置关系
  >
  > ​        y 是直线上的点

<div STYLE="page-break-after: always;"></div>
<!--这里有个分页符-->  

### 算法书写示例

```C++
void Midpoint Line (int x0, int y0, int x1, int y1, int color){   
    int a, b, delta1, delta2, d, x, y;
    a = y0-y1, b = x1-x0, d = 2*a+b;
    delta1 = 2*a, delta2 = 2*(a+b);
    x = x0, y = y0;
    putpixel(x, y, color);
    while(x < x1){ 
        if (d<0){x++, y++, d += delta2;}    // 选择右上方象素
        else    {x++, d += delta1;}		 // 选择正右方象素
        putpixel(x, y, color);
     }  /* while */
 } /* mid PointLine */

```

-----

### 例题 : 用中点画线算法绘制 $P_0 (0, 0) -> P_1 (5, 2)$

![image-20210607165244633](http://cdn.ayusummer233.top/img/image-20210607165244633.png)

------

# Bresenham 画圆算法

- [参考链接 : Bresenham直线算法与画圆算法 - ZYVV - 博客园 (cnblogs.com)](https://www.cnblogs.com/wlzy/p/8695226.html)

------

- Bresenham 画圆算法又称中点画圆算法，与 Bresenham 直线算法一样，其基本的方法是利用判别变量来判断选择最近的像素点，判别变量的数值仅仅用一些加、减和移位运算就可以计算出来。为了简便起见，考虑一个圆心在坐标原点的圆，而且只计算第一象限圆周上的点，其余圆周上的点利用对称性就可得到。

- 该算法以点 $(0, r)$ 为起点，按顺时针方向生成圆时，相当于在第一象限内，所以 y 是 x 的单调递减函数。

  ![image-20210607170134189](http://cdn.ayusummer233.top/img/image-20210607170134189.png)

- 从圆上任一点出发，按顺时针方向生成圆时，为了最佳地逼近该圆，对于下一个象素的取法只有三种可能的选择，即右方象素(H)、右下角象素(D)、下方象素(V)。

  ![image-20210607170229754](http://cdn.ayusummer233.top/img/image-20210607170229754.png)

  **设** $△_i = (x_i + 1)^2 + (y_i - 1)^2 - r^2$  $->$  D 点与圆心间距的平方

  - **若** $△_i < 0,$ 则右下角点在圆内，此时只可能取象素点 H 或 D

     **设** $δ_1 = |(x_i + 1)^2 + (y_i)^2 - r^2| - |(x_i + 1)^2 + (y_i - 1)^2 - r^2|$  ->  比较 H 点与 D 点与圆心间距的大小

    - $δ_1 < 0$ 取H  ->  H 点距离圆心更近
    - $δ_1 > 0$ 取D  -> D 点距离圆心更近
    - $δ_1 == 0$ 二者距离相等，规定取右方象素 H

  ​        并可将 $δ_1$ 进一步化简成  $δ_1 = 2(△_i + y_i) - 1$

  - **若** $△_i > 0,$ 则右下角点在圆外，此时只可能取象素点 D 或 V

    **设** $δ_2 = |(x_i + 1)^2 + (y_i - 1)^2 - r^2| - |{x_i}^2 + (y_i - 1)^2 - r^2|$  ->  比较 D 点与 V 点与圆心间距的大小

    - $δ_2 < 0$ 取 D  $->$  D 点距离圆心更近
    - $δ_2 > 0$ 取 V  $->$  V 点距离圆心更近
    - $δ_2 == 0$ 二者距离相等，规定取右下角象素 D

    ​        并可将 $δ_2$ 进一步化简成  $δ_2 = 2(△_i - x_i) - 1$

  - **若** $△_i == 0$, 则 D 点在圆弧上, 取 D 点

  据此，可导出简单增量算法的递推公式:

  若设当前圆上点所在的象素为第 i 个象素，下一个新象素为第 i+1 个象素，则新象素的坐标及 △ 值的递推公式是:

  - 新象素为 H 时:

    $x_{i+1} = x_i + 1 \\ y_{i+1} = y_i \\ △_{i+1} ＝ △_i+2x_{i+1} + 1$

  > ![image-20210608163429855](http://cdn.ayusummer233.top/img/image-20210608163429855.png)
  >
  > $△_{i+1} = (x_{i+1} + 1)^2 + (y_{i+1}-1)^2 - r^2 \\ = (x_i + 1 + 1)^2 + (y_i - 1)^2 - r^2 \\ = (x_i+1)^2 + 2(x_i + 1)^2 + 1 + (y_i - 1)^2 - r^2 \\ = (x_i+1)^2 + (y_i - 1)^2 - r^2 + 2(x_i + 1)^2 + 1 \\ = △_i + 2x_{i+1} + 1$

  - 新象素为 D 时:

    $x_{i+1} = x_i + 1 \\ y_{i+1} = y_i - 1 \\  △_{i+1} = △_i + 2x_{i+1}-2y_{i+1}+2$

  - 新象素为 V 时:

    $x_{i+1} = x_i  \\  y_{i+1}＝y_i-1  \\  △_{i+1} ＝ △_i - 2y_{i+1}+1 $

  
<div STYLE="page-break-after: always;"></div>
<!--这里有个分页符-->

---------

  > 在 $△_i < 0$ (右下角点 D 在圆内)中的进一步简化的过程推导如下:
  >
  > 法 1 (老师的超星视频讲解):
  >
  > $δ_1 = |(x_i + 1)^2 + (y_i)^2 - r^2| - |(x_i + 1)^2 + (y_i - 1)^2 - r^2|$
  >
  > 将上式两部分用如下方法替换表示一下:
  >
  > $δ_1 = |S(H)| - |S(D)|$
  >
  > 结合实际图形来看要想去绝对值要考虑 3 种情况:
  >
  > ![image-20210608151353358](http://cdn.ayusummer233.top/img/image-20210608151353358.png)
  >
  > - ( 1 ) D 点在圆内  $->$ $S(H) > 0, S(D) < 0$  ->  $δ_1 = |S(H)| - |S(D)| = S(H) + S(D)$
  >
  > - ( 2 ) 圆弧恰好过 H 点  $->$ $S(H) = 0, S(D) < 0$  $ -> $  $δ_1 = |S(H)| - |S(D)| = S(H) + S(D)$ 
  >
  > - ( 3 ) D, H 均在圆内  $->$  $S(H) < 0, S(D) < 0$  $->$  $δ_1 = |S(H)| - |S(D)| = -S(H) + S(D)$
  >
  >   这里发现这种情况下的式子比上面两种情况多个负号, 但是实际上这种情况下两点都在圆内, **显然 H 点距离圆周更近**, 应当选择 H 点;
  >
  >   那么如果把这里的 $δ_1 = |S(H)| - |S(D)| = -S(H) + S(D)$ 改成 $δ_1 = |S(H)| - |S(D)| = S(H) + S(D)$
  >
  >   那么由于 $S(H) < 0, S(D) < 0$ 因此 $δ_1 < 0$, 根据原本规则下的 3 种情况仍然应当选择 H 点, 因此这种改写从结果上来看是可取的
  >
  > 综上所述并结合 $△_i = (x_i + 1)^2 + (y_i - 1)^2 - r^2$ 
  >
  > $δ_1 = |S(H)| - |S(D)| = S(H) + S(D) \\ = 2(x_i + 1)^2 - 2r^2 + 2y_i^2 - 2y_i + 1 \\ = 2(x_i + 1)^2 + 2(y_i - 1)^2 + 2y -1 - 2r^2 \\ = 2△_i + 2y - 1 \\ = 2(△_i + y_i) - 1$
  >
  > > PS: 若 $△_i > 0$ 中的进一步简化为的详细步骤推导与此处的推导思路一致, 不再赘述

---------------
<div STYLE="page-break-after: always;"></div>
<!--这里有个分页符-->  

  > 法 2 (从源头分叉用另一种关系来确定点的选取)[只看法 1 就够了, 因为法 2 是最开始产生疑惑时在网上找到的一位博主写的博客,觉得写的不错就做了记录而且关于点的选取与圆的位置关系的推导那部分没整理完]
  >
  > [参考链接 : Bresenham 画圆算法原理_在到处之间找我-CSDN博客_bresenham算法画圆](https://blog.csdn.net/sinat_41104353/article/details/82961824)
  >
  > 除了用点距圆心的距离来决定选择哪个点之外还可以如下所示(距离圆周曲线更近):
  >
  > ![image-20210608142602176](http://cdn.ayusummer233.top/img/image-20210608142602176.png)
  >
  > $d_H$ 更小, 下一个像素点就选 H 
  >
  > $d_D$ 更小, 下一个像素点就选 D
  >
  > $d_H == d_D$, 按照之前上面的规定选 H
  >
  > 但是要求 $d_H$ 和 $d_D$ 仍显得不简单,所以在近似一下:
  >
  > 将 H 点与 D 点分别和圆心相连并交圆周于 C 点与 B 点:
  >
  > ![image-20210608184301144](http://cdn.ayusummer233.top/img/image-20210608184301144.png)
  >
  > 将图放大一下:
  >
  > ![image-20210608170849835](http://cdn.ayusummer233.top/img/image-20210608170849835.png)
  >
  > 原本的 $d_H$ 与 $d_D$ 相比近似到 CH 与 BD 相比(大概是因为一个像素点的偏移可以近似看做 CH // BD? 不过这样近似起来确实好算了)
  >
  > $CH^2 = (OH - OC)^2 = (x_i + 1)^2 + {y_i}^2 - r^2$
  >
  > $DH^2 = (OB - OD)^2 = r^2 - (x_i + 1)^2 - (y_i - 1)^2$
  >
  > 然后将二者做差处理得:
  >
  > $CH^2 - DH^2 = 2(x_i + 1)^2 - 2r^2 + y_i^2 + (y_i - 1)^2 \\ = 2(x_i + 1)^2 - 2r^2 + 2y_i^2 - 2y_i + 1 \\ = 2(x_i + 1)^2 + 2(y_i - 1)^2 + 2y -1 - 2r^2$
  >
  > 然后再看一下原来的  $△_i = (x_i + 1)^2 + (y_i - 1)^2 - r^2$, $δ_1 = 2(△_i + y_i) - 1$ 
  >
  > 用 $△_i$ 来改写 $CH^2 - DH^2$ 的话就是:
  >
  > $CH^2 - DH^2 = 2△_i + 2y - 1 \\ = 2(△_i + y_i) - 1 = δ_1$

--------
<div STYLE="page-break-after: always;"></div>
<!--这里有个分页符-->


## 算法描述

- 绘制第 1 象限的圆弧, 从 (0, r) 开始绘制 [PS: 要求 r 为整数, 也就是说这就是绘制的第一个像素点了]

  ![image-20210607170134189](http://cdn.ayusummer233.top/img/image-20210607170134189.png)

- 第 1 象限每绘制 1 个点就可以利用对称性对称到 2,3,4 周期绘制相应像素点

```c++
// x 与 y 为绘制像素点坐标, 均为整型数据  
x＝0;                                                                                                               
y＝r;
delta＝2*(1-r);    //  起点右下角点(1, r-1)
while(y ＞＝ 0){            
    putpixel(x,  y,  pixelco1or); 	// 第 1 象限点绘制
    putpixel(-x, y,  pixelco1or);   // 对称到第 2 象限点绘制
    putpixel(x,  -y, pixelco1or);   // 对称到第 4 象限点绘制
    putpixel(-x, -y, pixelco1or);   // 对称到第 3 象限点绘制
    if(delta＜0) {            // H 或 D
        delta1＝2*(delta+y)-1,
        if(deltal＜=0)  		 // H
            direction＝1;
        else  direction＝2;   // D
    }
    else  if(delta＞0){ 		 // D 或 V
        delta2＝2*(delta一x)-1; 
        if(delta2＜＝0)  		// D
            direction＝2; 
        else  direction＝3;   // V
    }
    else
        direction ＝2;        // D
    switch(direction){
        case 1: 	  // 取 H
            x++;                    
            delta+＝2＊x+1;
            break:
        case 2: 	 // 取 D
            x++;                    
            y--;
            delta+＝2*(x-y+1);
            break;
        case 3:  	// 取 V
            y--;                    
            delta+＝(-2*y+1);
            break;          　　 　 
	｝// End of switch
｝//  End of whi1e  
```

# 自由曲线绘制方法 & Bezier 样条曲线

>  两者一起考

## 简述自由曲线绘制方法

- 自由曲线是没有一个明确的参数方程对整条曲线进行描述的一类曲线, 所以对于自由曲线的绘制要转换成样条曲线来进行绘制;
- 对于样条曲线而言, 它是规则的曲线, 有明确的参数方程; 所以我们利用样条曲线的参数方程, 让参变量 t = 0 开始以一定步长递增到 1 为止把样条曲线上的点计算出来, 然后相邻的点用小直线段连接, 把这样一段样条曲线绘制出来, 当自由曲线分解得到的样条曲线均绘制完成时就完成了对整条自由曲线的绘制

------

## 举例绘制 Bezier 样条曲线

- 然后举其中某一次 Bezier 样条曲线为例写出绘制代码

  -------
### 实验代码

  ```python
  # @Function  : 绘制三次 Bezier 曲线
  import matplotlib.pyplot as plt
  import numpy as np
  
  
  def Bezier_3_generate_axis(p0: list, p1: list, p2: list, p3: list):
      """通过 4 个控制点求横纵坐标序列并返回
      p0 ~ p3 即为四个控制点, t -> [0, 1]
      """
      x0 = p0[0]
      x1 = p1[0]
      x2 = p2[0]
      x3 = p3[0]
      y0 = p0[1]
      y1 = p1[1]
      y2 = p2[1]
      y3 = p3[1]
      ax = -x0 + 3 * x1 - 3 * x2 + x3
      ay = -y0 + 3 * y1 - 3 * y2 + y3
      bx = 3 * x0 - 6 * x1 + 3 * x2
      by = 3 * y0 - 6 * y1 + 3 * y2
      cx = -3 * x0 + 3 * x1
      cy = -3 * y0 + 3 * y1
      dx = x0
      dy = y0
      t = np.linspace(0, 1)
      x = ax * (t ** 3) + bx * (t ** 2) + cx * t + dx
      y = ay * (t ** 3) + by * (t ** 2) + cy * t + dy
      return [x, y]
  
  
  
  
  def Bezier_3_generate_axis_on_line(p0: list, p1: list, p2: list, p3: list):
      """通过曲线上 4 个点反求控制点并求横纵坐标序列并返回
      p0 ~ p3 即为四个曲线上的点, t -> [0, 1]
      """
      B = np.mat([
          [1, 0, 0, 0],
          [8 / 27, 4 / 9, 2 / 9, 1 / 27],
          [1 / 27, 2 / 9, 4 / 9, 8 / 27],
          [0, 0, 0, 1]
      ])
      C = np.mat([
          p0, p1, p2, p3
      ])
      P = B.I * C
      P = P.tolist()
      print(type(P))
      print(P)
      return Bezier_3_generate_axis(P[0], P[1], P[2], P[3])
  
  
  
  
  
  def Bezier3_4control_point_draw(p0: list, p1: list, p2: list, p3: list):
      """通过 4 个控制点绘制贝塞尔曲线
  
      """
      x_lst = Bezier_3_generate_axis(p0, p1, p2, p3)[0]
      y_lst = Bezier_3_generate_axis(p0, p1, p2, p3)[1]
      # 使用黑体
      plt.rcParams['font.family'] = ['simhei']
      plt.rcParams['axes.unicode_minus'] = False
      plt.title('根据 4 个控制点绘制的 Bezier 曲线图', size=16)  # 设置图的标题
      plt.xlabel('x 值', labelpad=10)  # 设置X轴的名称
      plt.ylabel('函\n数\n值',
                 rotation=0,  # 文本中的文字水平显示
                 linespacing=2,  # 行距
                 labelpad=20,  # 文本名称与坐标轴的距离
                 position=(10, 0.35)  # 文本名称的纵坐标（第2个数值）
                 )
      plt.scatter(p0[0], p0[1])
      plt.scatter(p1[0], p1[1])
      plt.scatter(p2[0], p2[1])
      plt.scatter(p3[0], p3[1])
      plt.plot(x_lst, y_lst)  # 画折线图
      plt.show()
      
      
      
      
      
      
      
      
      
      
      
      
  def Bezier3_4point_on_curve_draw(p0: list, p1: list, p2: list, p3: list):
      """通过 4 个曲线上的点绘制内塞尔曲线
  
      """
      x_lst = Bezier_3_generate_axis_on_line(p0, p1, p2, p3)[0]
      y_lst = Bezier_3_generate_axis_on_line(p0, p1, p2, p3)[1]
      # 使用黑体
      plt.rcParams['font.family'] = ['simhei']
      plt.rcParams['axes.unicode_minus'] = False
      plt.title('根据 4 个曲线上的点绘制的 Bezier 曲线图', size=16)  # 设置图的标题
      plt.xlabel('x 值', labelpad=10)  # 设置X轴的名称
      plt.ylabel('函\n数\n值',
                 rotation=0,  # 文本中的文字水平显示
                 linespacing=2,  # 行距
                 labelpad=20,  # 文本名称与坐标轴的距离
                 position=(10, 0.35)  # 文本名称的纵坐标（第2个数值）
                 )
      plt.scatter(p0[0], p0[1])
      plt.scatter(p1[0], p1[1])
      plt.scatter(p2[0], p2[1])
      plt.scatter(p3[0], p3[1])
      plt.plot(x_lst, y_lst)  # 画折线图
      plt.show()
  ```

--------

### 三次 Bezier 曲线

三次贝塞尔曲线的公式如下所示:

  ![img](http://cdn.ayusummer233.top/img/wps1.jpg)

三次Bezier曲线的矩阵表示形式如下:

![img](http://cdn.ayusummer233.top/img/wps2.jpg)

分解后的参数式为:

![img](http://cdn.ayusummer233.top/img/wps3.jpg)

式中系数分别为:

![img](http://cdn.ayusummer233.top/img/wps4.jpg)

根据 4 个控制点即可求出所在区间的曲线上的各点坐标然后就可以通过 plt 函数直接绘制曲线了:

```python
def Bezier_3_generate_axis(p0: list, p1: list, p2: list, p3: list):
    """通过 4 个控制点求横纵坐标序列并返回
    p0 ~ p3 即为四个控制点, t -> [0, 1]
    """
    x0 = p0[0]
    x1 = p1[0]
    x2 = p2[0]
    x3 = p3[0]
    y0 = p0[1]
    y1 = p1[1]
    y2 = p2[1]
    y3 = p3[1]
    ax = -x0 + 3 * x1 - 3 * x2 + x3
    ay = -y0 + 3 * y1 - 3 * y2 + y3
    bx = 3 * x0 - 6 * x1 + 3 * x2
    by = 3 * y0 - 6 * y1 + 3 * y2
    cx = -3 * x0 + 3 * x1
    cy = -3 * y0 + 3 * y1
    dx = x0
    dy = y0
    t = np.linspace(0, 1)
    x = ax * (t ** 3) + bx * (t ** 2) + cx * t + dx
    y = ay * (t ** 3) + by * (t ** 2) + cy * t + dy
    return [x, y]
```

-----

- 当已知 4 点为在曲线上的点时首先要反求控制点

  曲线公式:

  ![img](http://cdn.ayusummer233.top/img/wps5.jpg)

  曲线多项式:

  ![img](http://cdn.ayusummer233.top/img/wps6.jpg)

  反求控制点:

  ![image-20210608210417987](http://cdn.ayusummer233.top/img/image-20210608210417987.png)

  反求完控制点集 P 后再套用上面的代码求曲线上的点再绘图即可

-----

### Bezier 曲线

- Bezier曲线通过一组多边折线的各顶点唯一的定义出来。

- 在多边折线的各顶点中，只有**第一点和最后一点在曲线上**，其余的顶点则用来定义曲线的导数，阶次和形状。**第一条边和最后一条边分别和曲线在起点和终点处相切**，曲线的形状趋于多边折线的形状，改变多边折线的顶点位置和曲线形状的变化有着直观的联系。多边折线称为**特征多边形**，其顶点称为**控制点**。

- Bezier 曲线的参数方程:

     $Q(t) = \sum_{i=0}^{n} P_iB_{i,n}(t), (0<=t<=1)$

  - $P_i( i = 0, 1, 2,…., n )$ 是空间给定的  n＋1 个点的位置向量，也称控制点，它们构成了控制 Bezier 曲线形状的特征多边形。
  - $B_{i,n}(t)$ 为 **Bernstain** **基函数**。

-------

### 二次 Bezier 曲线

- 当 n＝2 时，上式即为二次 Bezier 曲线表达式。二次 Bezier 曲线有三个控制点，它是一条经过 P0 和 P2 两个控制点的抛物线。

    它的矩阵表示形式如下：

  ![image-20210608224220444](http://cdn.ayusummer233.top/img/image-20210608224220444.png)

  若将上式中的向量 P0、P1、P2 分解为二维平面上的 x 及 y 方向分量，就可得到二次 Bezier 曲线的参数式：

  ![image-20210608224342469](http://cdn.ayusummer233.top/img/image-20210608224342469.png)

  式中系数分别为：

  ![image-20210608224411382](http://cdn.ayusummer233.top/img/image-20210608224411382.png)

> 参数方程一上, 上面绘制三次曲线的代码改一下生成函数就能直接用了

- 二段二次 Bezier 曲线在满足一定条件的情况下可以达到 $C^1$ 连续:

  $P_2 = P_3$

  $P_4$ 应在 $P_1P_2$ 的延长线上

  ![image-20210608224730257](http://cdn.ayusummer233.top/img/image-20210608224730257.png)



-----

# 区域填充
- 与中点画线算法的考法类似, 首先请大家描述一下区域填充的算法, 然后给出一个例子, 根据算法把给出的区域填充好(要知道填充的时候不同位置处填充的先后次序)(看看给的例子里所涉及的区域当中的像素点和填充次序是怎样的)

-------

- 描述: 区域填充是指对一个区域进行重新着色的过程; 在区域中选择一个种子点, 然后将所要着色的颜色从种子点开始往四周扩散, 直到扩散到整个区域, 把整个区域的所有像素点都用这种颜色显示为止;

---------

- 例子:

  ![image-20210609122931829](http://cdn.ayusummer233.top/img/image-20210609122931829.png)



-------

# 三维图形几何变换

- 考察几何变换的方法, 会给出具体的示例, 让大家求这个变换中的变换矩阵

  肯定考得是复杂几何变换, 要分解成基本几何变换, 要求的矩阵就是所涉及的基本变换矩阵的乘积

![image-20210609123425823](http://cdn.ayusummer233.top/img/image-20210609123425823.png)

- 比例变换

  ![image-20210609123456437](http://cdn.ayusummer233.top/img/image-20210609123456437.png)

  - 对称变换

    - 关于 xoy 平面对称

    ![image-20210609123520495](http://cdn.ayusummer233.top/img/image-20210609123520495.png)

    - 关于 xoz 平面对称变换

      ![image-20210609123613349](http://cdn.ayusummer233.top/img/image-20210609123613349.png)

    - 关于 yoz 平面对称
      ![image-20210609123645408](http://cdn.ayusummer233.top/img/image-20210609123645408.png)

  ---

  - 错切边换

    ![image-20210609123756419](http://cdn.ayusummer233.top/img/image-20210609123756419.png)

    ![image-20210609123909159](http://cdn.ayusummer233.top/img/image-20210609123909159.png)

    ![image-20210609123927219](http://cdn.ayusummer233.top/img/image-20210609123927219.png)

    ![image-20210609123941855](http://cdn.ayusummer233.top/img/image-20210609123941855.png)

    ----

    - 旋转变换

      ![image-20210609124026780](http://cdn.ayusummer233.top/img/image-20210609124026780.png)

      ![image-20210609124046862](http://cdn.ayusummer233.top/img/image-20210609124046862.png)

      ![image-20210609124059349](http://cdn.ayusummer233.top/img/image-20210609124059349.png)

    ----

    - 平移变换

      ![image-20210609124159003](http://cdn.ayusummer233.top/img/image-20210609124159003.png)

    ----

    ![image-20210609124236475](http://cdn.ayusummer233.top/img/image-20210609124236475.png)

    ![image-20210609124256516](http://cdn.ayusummer233.top/img/image-20210609124256516.png)

    ![image-20210609124332845](http://cdn.ayusummer233.top/img/image-20210609124332845.png)

    ![image-20210609124349863](http://cdn.ayusummer233.top/img/image-20210609124349863.png)

    ![image-20210609124403857](http://cdn.ayusummer233.top/img/image-20210609124403857.png)

    ![image-20210609124418118](http://cdn.ayusummer233.top/img/image-20210609124418118.png)

    ![image-20210609124441889](http://cdn.ayusummer233.top/img/image-20210609124441889.png)

    

    

-------

# 编码裁剪算法

- 也与中点画线算法的考法一致, 首先描述一遍编码裁剪算法;

  然后会给出一个具体的实例,  用编码裁剪算法把例子中的线段进行裁剪: 要求描述裁剪过程, 不能只是直接把最后裁剪出的线段画出来

  > 凡是涉及到算法应用的, 都是要把中间过程一步一步的结果写出来的, 中间结果一定要完整



----

- 算法描述: 核心思想为:分区编码.线段分割

----

![image-20210609124749480](http://cdn.ayusummer233.top/img/image-20210609124749480.png)

![image-20210609124942017](http://cdn.ayusummer233.top/img/image-20210609124942017.png)

![image-20210609125002689](http://cdn.ayusummer233.top/img/image-20210609125002689.png)

![image-20210609125108061](http://cdn.ayusummer233.top/img/image-20210609125108061.png)



----

# 八叉树表示法

- 对于三维形体采用八叉树表示法进行描述的话. 表示的基本原理和过程是怎样的(上课讲过, 看下超星视频)

  八叉树表示法的缺点和对应改善方法(看下超星视频)

----

- 过程: 当把三维物体所占据的空间不断进行分割, 当分割以后的立方体越来越小逐步接近于用空间点的集合表示三维物体

![image-20210609125717475](http://cdn.ayusummer233.top/img/image-20210609125717475.png)

![image-20210609125736372](http://cdn.ayusummer233.top/img/image-20210609125736372.png)

![image-20210609125750578](http://cdn.ayusummer233.top/img/image-20210609125750578.png)

- 对于存储量大的缺点有改进的方法: 用线性八叉树的方式来表达, 对于一个三维形体最终是用标识为负的立方体表达的, 那么只记录标识为负的立方体,将这些立方体用个数组来表达



------

# 透视投影 & 观察空间的定义

- 放在一起考

  描述透视投影的观察空间的定义的方法

  观察空间的定义包括两个步骤

  ​	    观察坐标系的定义

  ​        在观察坐标系的基础上定义观察空间

  > 一定要先写观察坐标系的定义再写观察空间的定义

  把当时讲过的定义观察空间的那些参数的缺省取值, 在缺省取值情况下透视投影的观察空间是什么样子的,怎么画出来的



----

# 扫描线消隐算法

- 描述一下扫描线消隐算法的算法步骤

  然后回答一下为了提高扫描线消隐算法的效率需要解决什么问题, 怎么解决

  ​        要解决 4 个问题, 前 3 个问题用数据结构解决, 第 4 个问题使用相关性解决

  > 要写清楚写具体每一个问题是用什么解决的

圈1 多边形y桶 圈2 多边形活化表 圈3 边活化表 圈4 相关性

-----

# 多边形明暗处理

- 描述一下多边形明暗处理的背景方法, 具体的过程

  > 思想,步骤,公式......... 

