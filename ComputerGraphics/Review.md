<!--
 * @Author: 咸鱼型233
 * @Date: 2021-06-07 13:25:57
 * @LastEditTime: 2021-06-07 16:55:45
 * @LastEditors: Please set LastEditors
 * @Description: 图形学考前复习
 * @FilePath: \JuniorLesson_SecondTerm\ComputerGraphics\Review.md
    -->



------

# 目录

- [目录](#目录)
- [中点画线算法](#中点画线算法)
  - [DDA 算法](#dda-算法)
  - [中点画线算法](#中点画线算法-1)
    - [实现整数运算](#实现整数运算)
    - [算法书写示例](#算法书写示例)
    - [例题 : 用中点画线算法绘制 $P_0 (0, 0) -> P_1 (5, 2)$](#例题--用中点画线算法绘制-p_0-0-0---p_1-5-2)
- [Bresenham 画圆算法](#bresenham-画圆算法)



---

# 中点画线算法
- 先考算法描述然后再举个例子

    ----
- 首先要明白中点画线算法是一种直线的生成算法,而说到直线的生成算法那么首先要提一下生成直线的 DDA(Digital Differential Analyzer) 算法(又称数值微分法)

    ---
## DDA 算法
- DDA算法是计算机图形学中最简单的绘制直线算法。其主要思想是由直线公式 $y = kx + b$ 推导出来的。我们已知直线段两个端点 $P0(x0,y0)$ 和 $P1(x1,y1)$，就能求出 $k$ 和 $b$ 
  
    ---
-  无论是显示器还是绘图机，都可以看成有一个网格(离散单元组成的矩阵)存在，对显示器来说每一个像素就是一个网格点，对绘图机来说笔每走一步的终点也可以看成是一个网格的结点。
- 在显示器上表示一条直线, 就是要用最靠近直线的一些网格点来代表这一直线。这个网格就构成屏幕和绘图机纸张的一个坐标系，相邻两个网点的距离取为1，每个网格点的坐标均取整数。    

  ![20210607134530](http://cdn.ayusummer233.top/img/20210607134530.png)

- 假设直线的起点坐标为 $P1 (x1,y1)$. 终点坐标为 $P2 (x2,y2)$, x 方向的增量为 $△x＝x2-x1$; y方向上增量为 $△y＝y2-y1$  
   那么直线的斜率 $k＝△y／△x$    
   当 $△x＞△y$ 时，让 x 从 x1 到 x2 变化，每步递增 1   
   那么 x 的变化可以表示为 $x_{i+1}＝xi+1$    
   y 的变化可以表示为 $y_{i+1}＝yi+k$
- 用上式可求得图中直线 P1P2 和 y 方向网格线的交点，但显示时要用象素点(图中的网格结点)耒表示，所以要用舍入的办法耒找到最靠近交点处的象素点，并用其耒表示直线段。
- 这个方法称之为数字微分分析法，简称DDA。

    ---
  ![20210607135102](http://cdn.ayusummer233.top/img/20210607135102.png)    
  `int(x)` 会把 x 的小数部分去掉保留整数部分, `int(x+0.5)` 可以用来四舍五入
- 算法描述如下:
  ```C++
  int  x1, y1, x2, y2;
  int  x;
  double dx, dy, k, y;
  dx ＝ x2 - x1;
  dy ＝ y2 - y1;
  k ＝ dy / dx;
  x ＝ x1;
  y ＝ y1;
  if(abs(k) < 1)
    for( ; x＜＝x2; x++){ 
        putpixel(x, (int)(y+0.5), pixelcolor);
        y＝y+k;
    }
  else
    for( ; y＜＝y2; y++){ 
    putpixel((int)(x+0.5), y, pixelcolor);
    x ＝ x + 1/k;
    }
  ```
  - 最后的 `if-else` 逻辑要将变化幅度小的一方作为度量, 这样可以画更多点使得曲线更准确

    ---
## 中点画线算法
- 采用增量思想的 DDA 算法, 每计算一个象素只需计算一个加法，是否最优？
  - 不是,因为算法里含有浮点数运算
  
- `目标` : 进一步将一个加法改为一个整数加法。

- DDA 算法采用直线的点斜式方程, 中点画线算法采用直线的隐式方程

- 设直线段的起点和终点分别为: $(x0, y0), (x1,y1)$  
   $F(x,y)=ax+by+c=0$     
   $a=y0-y1$  
   $b=x1-x0$    
   $c=x0y1-x1y0$     
   均为整数
   
-  `基本思想` : 设当前象素点为 $(xp, yp)$ ，下一个象素点为 P1 或 P2       
  设 $M=(xp+1, yp+0.5)$即为 $p1$ 与 $p2$ 的中点，Q 为实际直线与 $x=xp+1$ 的交点。将 Q 与 M 的 y 坐标进行比较。   

  - 若 M 在 Q 的下方，应取 P2 为下一点
  - 若 M 在 Q 的上方，应取 P1 为下一点
  
    ![image-20210607155126647](http://cdn.ayusummer233.top/img/image-20210607155126647.png)

- 直线的正负划分性

  - 直线上方点 : $F(x,y)＞0$

  - 直线下方的点 : $F(x,y)＜0$

    ![image-20210607162025808](http://cdn.ayusummer233.top/img/image-20210607162025808.png)



-----

- 构造判别式 : $d=F(M)=F(xp+1,yp+0.5) \\ =a(xp+1)+b(yp+0.5)+c$

  其中 $a=y0-y1, b=x1-x0, c=x0y1-x1y0$

  - 若 d < 0 : M 在直线( Q 点)下方，取右上方 P2 为下一个象素
  - 若 d > 0 : M 在直线( Q 点)上方，取右方 P1 为下一个象素
  - 若 d == 0 : 选 P1 或 P2 均可，约定取 P1 为下一个象素

  ![image-20210607162159336](http://cdn.ayusummer233.top/img/image-20210607162159336.png)

  - 增量算法

    - 若当前象素处于 $d >= 0$ 情况，则取正右方象素 $P1 (xp+1, yp)$,  要判下一个象素位置，应计算

      $d1=F(xp+2, yp+0.5)=a(xp+2)+b(yp+0.5)+c=d+a$    -> 增量 delta1 为 a  

    - d < 0 时, 则取右上方象素 $P2 (xp+1, yp+1)$, 要判断再下一象素，则要计算

      $d2= F(xp+2, yp+1.5)=a(xp+2)+b(yp+1.5)+c=d+a+b$  ->  增量 delta2 为 a+b   

### 实现整数运算

- 画线从起点 $(x0, y0)$ 开始, d 的初值

  $d0=F(x0+1, y0+0.5)=F(x0, y0)+a+0.5b =a+0.5b$

  - 解决方法 : 2d 代替 d, 则

    $d0=2d0=2a+b$

    $d1=2d1=2d+2a$  ->  增量 delta1 = 2a

    $d2=2d2=2d+2a+2b$  ->  增量 delta2 = 2a+2b

  > PS : 别把 d 和 y 弄混了, d 是用来判断 "中点" 和直线的位置关系的, 将 d 换成 2d 并不会影响 "中点" 与直线的位置关系
  >
  > ​        y 是直线上的点

  

### 算法书写示例

```C++
void Midpoint Line (int x0, int y0, int x1, int y1, int color){   
    int a, b, delta1, delta2, d, x, y;
    a = y0-y1, b = x1-x0, d = 2*a+b;
    delta1 = 2*a, delta2 = 2*(a+b);
    x = x0, y = y0;
    putpixel(x, y, color);
    while(x < x1){ 
        if (d<0){x++, y++, d += delta2;}    // 选择右上方象素
        else    {x++, d += delta1;}		 // 选择正右方象素
        putpixel(x, y, color);
     }  /* while */
 } /* mid PointLine */

```

-----

### 例题 : 用中点画线算法绘制 $P_0 (0, 0) -> P_1 (5, 2)$

![image-20210607165244633](http://cdn.ayusummer233.top/img/image-20210607165244633.png)

------

# Bresenham 画圆算法

- [参考链接 : Bresenham直线算法与画圆算法 - ZYVV - 博客园 (cnblogs.com)](https://www.cnblogs.com/wlzy/p/8695226.html)

------

- Bresenham 画圆算法又称中点画圆算法，与 Bresenham 直线算法一样，其基本的方法是利用判别变量来判断选择最近的像素点，判别变量的数值仅仅用一些加、减和移位运算就可以计算出来。为了简便起见，考虑一个圆心在坐标原点的圆，而且只计算第一象限圆周上的点，其余圆周上的点利用对称性就可得到。

- 该算法以点 $(0, r)$ 为起点，按顺时针方向生成圆时，相当于在第一象限内，所以 y 是 x 的单调递减函数。

  ![image-20210607170134189](http://cdn.ayusummer233.top/img/image-20210607170134189.png)

- 从圆上任一点出发，按顺时针方向生成圆时，为了最佳地逼近该圆，对于下一个象素的取法只有三种可能的选择，即右方象素(H)、右下角象素(D)、下方象素(V)。

  ![image-20210607170229754](http://cdn.ayusummer233.top/img/image-20210607170229754.png)

  **设** $△_i = (x_i + 1)^2 + (y_i - 1)^2 - r^2$  $->$  D 点与圆心间距的平方

  - **若** $△_i < 0,$ 则右下角点在圆内，此时只可能取象素点 H 或 D

     **设** $δ_1 = |(x_i + 1)^2 + (y_i)^2 - r^2| - |(x_i + 1)^2 + (y_i - 1)^2 - r^2|$  ->  比较 H 点与 D 点与圆心间距的大小

    - $δ_1 < 0$ 取H  ->  H 点距离圆心更近
    - $δ_1 > 0$ 取D  -> D 点距离圆心更近
    - $δ_1 == 0$ 二者距离相等，规定取右方象素 H

  ​        并可将 $δ_1$ 进一步化简成  $δ_1 = 2(△_i + y_i) - 1$

  - **若** $△_i > 0,$ 则右下角点在圆外，此时只可能取象素点 D 或 V

    **设** $δ_2 = |(x_i + 1)^2 + (y_i - 1)^2 - r^2| - |{x_i}^2 + (y_i - 1)^2 - r^2|$  ->  比较 D 点与 V 点与圆心间距的大小

    - $δ_2 < 0$ 取 D  $->$  D 点距离圆心更近
    - $δ_2 > 0$ 取 V  $->$  V 点距离圆心更近
    - $δ_2 == 0$ 二者距离相等，规定取右下角象素 D

    ​        并可将 $δ_2$ 进一步化简成  $δ_2 = 2(△_i - x_i) - 1$

  - **若** $△_i == 0$, 则 D 点在圆弧上, 取 D 点

  据此，可导出简单增量算法的递推公式:

  若设当前圆上点所在的象素为第 i 个象素，下一个新象素为第 i+1 个象素，则新象素的坐标及 △ 值的递推公式是:

  - 新象素为 H 时:

    $x_{i+1} = x_i + 1 \\ y_{i+1} = y_i \\ △_{i+1} ＝ △_i+2x_{i+1} + 1$

  > ![image-20210608163429855](http://cdn.ayusummer233.top/img/image-20210608163429855.png)
  >
  > $△_{i+1} = (x_{i+1} + 1)^2 + (y_{i+1}-1)^2 - r^2 \\ = (x_i + 1 + 1)^2 + (y_i - 1)^2 - r^2 \\ = (x_i+1)^2 + 2(x_i + 1)^2 + 1 + (y_i - 1)^2 - r^2 \\ = (x_i+1)^2 + (y_i - 1)^2 - r^2 + 2(x_i + 1)^2 + 1 \\ = △_i + 2x_{i+1} + 1$

  - 新象素为 D 时:

    $x_{i+1} = x_i + 1 \\ y_{i+1} = y_i - 1 \\  △_{i+1} = △_i + 2x_{i+1}-2y_{i+1}+2$

  - 新象素为 V 时:

    $x_{i+1} = x_i  \\  y_{i+1}＝y_i-1  \\  △_{i+1} ＝ △_i - 2y_{i+1}+1 $

  

  ---------

  > 在 $△_i < 0$ (右下角点 D 在圆内)中的进一步简化的过程推导如下:
  >
  > 法 1 (老师的超星视频讲解):
  >
  > $δ_1 = |(x_i + 1)^2 + (y_i)^2 - r^2| - |(x_i + 1)^2 + (y_i - 1)^2 - r^2|$
  >
  > 将上式两部分用如下方法替换表示一下:
  >
  > $δ_1 = |S(H)| - |S(D)|$
  >
  > 结合实际图形来看要想去绝对值要考虑 3 种情况:
  >
  > ![image-20210608151353358](http://cdn.ayusummer233.top/img/image-20210608151353358.png)
  >
  > - ( 1 ) D 点在圆内  $->$ $S(H) > 0, S(D) < 0$  ->  $δ_1 = |S(H)| - |S(D)| = S(H) + S(D)$
  >
  > - ( 2 ) 圆弧恰好过 H 点  $->$ $S(H) = 0, S(D) < 0$  $ -> $  $δ_1 = |S(H)| - |S(D)| = S(H) + S(D)$ 
  >
  > - ( 3 ) D, H 均在圆内  $->$  $S(H) < 0, S(D) < 0$  $->$  $δ_1 = |S(H)| - |S(D)| = -S(H) + S(D)$
  >
  >   这里发现这种情况下的式子比上面两种情况多个负号, 但是实际上这种情况下两点都在圆内, **显然 H 点距离圆周更近**, 应当选择 H 点;
  >
  >   那么如果把这里的 $δ_1 = |S(H)| - |S(D)| = -S(H) + S(D)$ 改成 $δ_1 = |S(H)| - |S(D)| = S(H) + S(D)$
  >
  >   那么由于 $S(H) < 0, S(D) < 0$ 因此 $δ_1 < 0$, 根据原本规则下的 3 种情况仍然应当选择 H 点, 因此这种改写从结果上来看是可取的
  >
  > 综上所述并结合 $△_i = (x_i + 1)^2 + (y_i - 1)^2 - r^2$ 
  >
  > $δ_1 = |S(H)| - |S(D)| = S(H) + S(D) \\ = 2(x_i + 1)^2 - 2r^2 + 2y_i^2 - 2y_i + 1 \\ = 2(x_i + 1)^2 + 2(y_i - 1)^2 + 2y -1 - 2r^2 \\ = 2△_i + 2y - 1 \\ = 2(△_i + y_i) - 1$
  >
  > > PS: 若 $△_i > 0$ 中的进一步简化为的详细步骤推导与此处的推导思路一致, 不再赘述

  ---------------

  > 法 2 (从源头分叉用另一种关系来确定点的选取)[只看法 1 就够了, 因为法 2 是最开始产生疑惑时在网上找到的一位博主写的博客,觉得写的不错就做了记录而且关于点的选取与圆的位置关系的推导那部分没整理完]
  >
  > [参考链接 : Bresenham 画圆算法原理_在到处之间找我-CSDN博客_bresenham算法画圆](https://blog.csdn.net/sinat_41104353/article/details/82961824)
  >
  > 除了用点距圆心的距离来决定选择哪个点之外还可以如下所示(距离圆周曲线更近):
  >
  > ![image-20210608142602176](http://cdn.ayusummer233.top/img/image-20210608142602176.png)
  >
  > $d_H$ 更小, 下一个像素点就选 H 
  >
  > $d_D$ 更小, 下一个像素点就选 D
  >
  > $d_H == d_D$, 按照之前上面的规定选 H
  >
  > 但是要求 $d_H$ 和 $d_D$ 仍显得不简单,所以在近似一下:
  >
  > 将 H 点与 D 点分别和圆心相连并交圆周于 C 点与 B 点:
  >
  > ![image-20210608144621715](http://cdn.ayusummer233.top/img/image-20210608144621715.png)
  >
  > 将图放大一下:
  >
  > ![image-20210608170849835](http://cdn.ayusummer233.top/img/image-20210608170849835.png)
  >
  > 原本的 $d_H$ 与 $d_D$ 相比近似到 CH 与 BD 相比(大概是因为一个像素点的偏移可以近似看做 CH // BD? 不过这样近似起来确实好算了)
  >
  > $CH^2 = (OH - OC)^2 = (x_i + 1)^2 + {y_i}^2 - r^2$
  >
  > $DH^2 = (OB - OD)^2 = r^2 - (x_i + 1)^2 - (y_i - 1)^2$
  >
  > 然后将二者做差处理得:
  >
  > $CH^2 - DH^2 = 2(x_i + 1)^2 - 2r^2 + y_i^2 + (y_i - 1)^2 \\ = 2(x_i + 1)^2 - 2r^2 + 2y_i^2 - 2y_i + 1 \\ = 2(x_i + 1)^2 + 2(y_i - 1)^2 + 2y -1 - 2r^2$
  >
  > 然后再看一下原来的  $△_i = (x_i + 1)^2 + (y_i - 1)^2 - r^2$, $δ_1 = 2(△_i + y_i) - 1$ 
  >
  > 用 $△_i$ 来改写 $CH^2 - DH^2$ 的话就是:
  >
  > $CH^2 - DH^2 = 2△_i + 2y - 1 \\ = 2(△_i + y_i) - 1 = δ_1$



--------

## 算法描述

- 绘制第 1 象限的圆弧, 从 (0, r) 开始绘制 [PS: 要求 r 为整数, 也就是说这就是绘制的第一个像素点了]

  ![image-20210607170134189](http://cdn.ayusummer233.top/img/image-20210607170134189.png)

- 第 1 象限每绘制 1 个点就可以利用对称性对称到 2,3,4 周期绘制相应像素点

```c++
// x 与 y 为绘制像素点坐标, 均为整型数据  
x＝0;                                                                                                               
y＝r;
delta＝2*(1-r);    //  起点右下角点(1, r-1)
// 第一象限圆弧绘制
while(y ＞＝ 0){            
    putpixel(x,  y,  pixelco1or); 	// 第 1 象限点绘制
    putpixel(-x, y,  pixelco1or);   // 对称到第 2 象限点绘制
    putpixel(x,  -y, pixelco1or);   // 对称到第 4 象限点绘制
    putpixel(-x, -y, pixelco1or);   // 对称到第 3 象限点绘制
    // H 或 D
    if(delta＜0) {           
        delta1＝2*(delta+y)-1,
        if(deltal＜=0)  		 // H
            direction＝1;
        else  direction＝2;   // D
    }
    // D 或 V
    else  if(delta＞0){
        delta2＝2*(delta一x)-1; 
        if(delta2＜＝0)  		// D
            direction＝2; 
        else  direction＝3;   // V
    }
    else
        direction ＝2;        // D
    switch(direction){
        // 取 H
        case 1: 
            x++;                    
            delta+＝2＊x+1;
            break:
        // 取 D
        case 2: 
            x++;                    
            y--;
            delta+＝2*(x-y+1);
            break;
        // 取 V
        case 3:  y――;                    
            delta+＝(-2*y+1);
            break;          　　 　 
	｝// End of switch
｝//  End of whi1e  

```

