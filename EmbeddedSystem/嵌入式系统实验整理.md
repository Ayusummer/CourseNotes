# 目录
- [目录](#目录)
- [实验2-跑马灯](#实验2-跑马灯)
  - [实验要求](#实验要求)
  - [源码](#源码)
    - [main.c](#mainc)
- [实验3-按键输入实验](#实验3-按键输入实验)
  - [实验要求](#实验要求-1)
  - [实验源码](#实验源码)
    - [多循环版](#多循环版)
    - [少循环版](#少循环版)
- [实验5-外部中断实验](#实验5-外部中断实验)
  - [实验要求](#实验要求-2)
  - [常见问题 & 建议](#常见问题--建议)
  - [设计思路](#设计思路)
  - [!20210422103117](#)
  - [实验程序](#实验程序)
- [实验6-独立看门狗实验](#实验6-独立看门狗实验)
  - [实验要求](#实验要求-3)
  - [设计思路](#设计思路-1)
    - [注意点](#注意点)
  - [常见问题](#常见问题)
    - [1.变量未定义(如:flag 未定义):](#1变量未定义如flag-未定义)
    - [2.中断无法判断(关于exti的全报错)](#2中断无法判断关于exti的全报错)
  - [源码](#源码-1)
    - [main.c](#mainc-1)
- [实验8-基本定时器实验](#实验8-基本定时器实验)
  - [实验内容](#实验内容)
  - [注意事项](#注意事项)
  - [源码](#源码-2)
    - [exti.c](#extic)
    - [timer.c](#timerc)
    - [main.c](#mainc-2)
- [实验9-PVM输出实验](#实验9-pvm输出实验)
  - [实验内容](#实验内容-1)
  - [源码](#源码-3)
    - [exti.c](#extic-1)
    - [exti.h](#extih)
    - [main.c](#mainc-3)
- [实验4-USART实验](#实验4-usart实验)
  - [实验内容](#实验内容-2)
  - [注意事项](#注意事项-1)
  - [Tips](#tips)
    - [#if,#endif](#ifendif)
  - [源码](#源码-4)
    - [usart.c](#usartc)
    - [main.c](#mainc-4)
- [实验18-ADC实验](#实验18-adc实验)
  - [实验内容](#实验内容-3)
  - [函数用法概览](#函数用法概览)
  - [调试记录](#调试记录)
    - [STM32常见错误error: #268: declaration may not appear after executable statement in block](#stm32常见错误error-268-declaration-may-not-appear-after-executable-statement-in-block)
  - [源码](#源码-5)
    - [main.c](#mainc-5)
- [实验20-DAC实验](#实验20-dac实验)
  - [实验内容](#实验内容-4)
  - [源码](#源码-6)
    - [main.c](#mainc-6)
- [实验56-UCOSII实验1-2任务调度](#实验56-ucosii实验1-2任务调度)
  - [实验内容](#实验内容-5)
  - [源码](#源码-7)
    - [main.c](#mainc-7)

# 实验2-跑马灯
- [参考链接](https://nosteglic.blog.csdn.net/article/details/108703814)[已失效]

---
## 实验要求
- 实现如下函数
  - `led_left()` : 实现led灯左移,右边灯亮，然后右边灯灭的同时左边灯亮。循环次数由函数入口参数决定。(`测试时左移3次`)
  - `led_ right()` : 实现led灯右移，左边灯亮，然后左边灯灭的同时右边灯亮。循环次数由函数入口参数决定。(`测试时右移3次`)
  - `led_ blink()` : 实现led灯闪烁，哪一个灯闪，闪的次数，都由函数入口参数决定。(`测试时0、 1、0&1各闪2次`)
  - `led_bcd()` : 实现0-3的数值的显示，比如0-00,1-01,2-10,3-11,显示的数值由函数入口参数决定。
- 函数写好后，在main()中分别进行调用演示。

---
## 源码

---
### main.c
```C
/*
 * @Author: your name
 * @Date: 2021-04-08 22:26:20
 * @LastEditTime: 2021-04-15 15:48:34
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \junior-lessons_second-term\EmbeddedSystem\Experiment\实验1-跑马灯\闪烁-两灯同时判断,同时执行闪烁.c
 */

#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"

// led灯左移,右边灯亮,然后右边灯灭的时候左边灯亮,循环次数由入口参数决定
void led_left(int x)        // x->循环次数
{
    while (x)                // 控制循环体执行次数为x
    {
        LED1 = 0;            //  右边灯亮
        LED0 = 1;            // 左边灯灭
        delay_ms(300);        // 延时300ms
        LED0 = 0;            // 左边灯亮
        LED1 = 1;            // 右边灯灭
        delay_ms(300);        // 延时300ms
        LED0 = LED1 = 1;    // 左右灯灭
        delay_ms(300);        // 延时300ms
        x -= 1;                // 循环次数-1
    }
}

// 与上面的反过来即可,led右移
void led_right(int x)
{
    while (x)
    {
        LED0 = 0;
        LED1 = 1;
        delay_ms(300);
        LED0 = 1;
        LED1 = 0;
        delay_ms(300);
        LED0 = LED1 = 1;
        delay_ms(300);
        x -= 1;
    }
}
/*
 ******* 没用到的代码    *********
int max(int a, int b){
    if(a>b) return a;
    else return b;
}

int min(int a, int b){
    if(a<b) return a;
    else return b;
}


int max_i(int a, int b){
    if(a>b) return 0;
    else return 1;
}
********************************
*/

int min_i(int a, int b){
    if(a<b) return 0;
    else return 1;
}

// led闪烁(和原始代码的表现形式一致)
void led_blink(int bcd_en, int left_times, int right_times)
{
    // 都亮
    if(bcd_en==0){
        if(min_i(left_times,right_times) == 0){
            while(left_times){
                LED0 = 0;
                LED1 = 0;
                delay_ms(300);
                LED0 = 1;
                LED0 = 1;        
                delay_ms(300);                                                             
                left_times -= 1;   
                right_times -= 1;         
            }
            while (right_times)
            {
                LED1 = 0;
                delay_ms(300);
                LED1 = 1;
                delay_ms(300);
                right_times -= 1;
            }
        }
        else{
            while(right_times){
                LED0 = 0;
                LED1 = 0;
                delay_ms(300);
                LED0 = 1;
                LED0 = 1;
                delay_ms(300);
                left_times -= 1;   
                right_times -= 1;         
            }
            while (left_times)
            {
                LED0 = 0;
                delay_ms(300);
                LED0 = 1;
                delay_ms(300);
                left_times -= 1;
            }
        }
    }

    // 左边灯亮
    if(bcd_en==1){
        while(left_times){
            LED0 = 0;
            delay_ms(300);
            LED0 = 1;
            delay_ms(300);
            left_times -= 1;
        }
    }

    // 右边灯亮
    if(bcd_en==2){
        while (right_times)
        {
            LED1 = 0;
            delay_ms(300);
            LED1 = 1;
            delay_ms(300);
            right_times -= 1;
        }
        LED1 = 1;
    }


    // 都不亮
    if(bcd_en==3){
        LED0 = LED1 = 1;
    }
}

// 0-3的数值的显示
// 四种情况是认为固定的,情况少而且不适合else if,直接全用if即可
void led_gcd(int x){
    if (x == 0) LED0 = LED1 = 0;
    if (x == 1) {LED0 = 0; LED1 = 1;}
    if (x == 2) {LED0 = 1; LED1 = 0;}
    if (x == 3) {LED0 = LED1 = 1;}
}



int main(void)
{ 
 
    delay_init(168);              // 初始化延时参数
    LED_Init();                    // 初始化LED端口
    
    led_left(3);

    led_right(3);
    
    led_blink(0,1,3);            // 左1右3
    led_blink(1,2,0);            // 左1右3
    led_blink(2,0,3);            // 左1右3
    led_blink(3,0,0);            // 左1右3
    
    led_gcd(0);
    delay_ms(1000);
    
    led_gcd(1);
    delay_ms(1000);
    
    led_gcd(2);
    delay_ms(1000);
    
    led_gcd(3);
    delay_ms(1000);

    while (1);
     
     
}



/**
*******************下面注释掉的代码是通过 位带 操作实现IO口控制**************************************
    
int main(void)
{ 
 
    delay_init(168);          //初始化延时函数
    LED_Init();                //初始化LED端口
  while(1)
    {
     LED0=0;              //LED0亮
       LED1=1;                //LED1灭
         delay_ms(500);
         LED0=1;                //LED0灭
         LED1=0;                //LED1亮
         delay_ms(500);
     }
}
**************************************************************************************************
 **/    
    
/**
*******************下面注释掉的代码是通过 直接操作寄存器 方式实现IO口控制**************************************
int main(void)
{ 
 
    delay_init(168);          //初始化延时函数
    LED_Init();                //初始化LED端口
    while(1)
    {
     GPIOF->BSRRH=GPIO_Pin_9;//LED0亮
       GPIOF->BSRRL=GPIO_Pin_10;//LED1灭
         delay_ms(500);
     GPIOF->BSRRL=GPIO_Pin_9;//LED0灭
       GPIOF->BSRRH=GPIO_Pin_10;//LED1亮
         delay_ms(500);

     }
 }     
**************************************************************************************************
**/    
```

----
# 实验3-按键输入实验
- [参考链接](https://nosteglic.blog.csdn.net/article/details/108704149)[已失效]

----
## 实验要求
- 按下KEY0后,LED0亮度由量变暗(呼吸灯效果),LED0亮的过程中无全灭无停顿感
- 按下KEY1后,LED0立刻熄灭

---
## 实验源码

---
### 多循环版
- `呼吸灯原理`:将呼/吸时间段划分成若干个周期,每个周期时间里灯泡亮的时间占比越来越低则越来越暗,越来越高则越来越亮
```C
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "beep.h"
#include "key.h"
typedef enum {FALSE = 0，TRUE = 1} bool；// bool宏定义

/*LED灯闪烁*/
void led_blink(u32 t,u32 bright){
    LED0=0;                  // 亮
    delay_us(bright);        // 保持亮,注意是us微秒
    LED0=1;                  // 暗
    delay_us(t-bright);      // 保持暗,注意是us微秒
}

/*熄灯判断*/
bool led_off(u8 key, int flag){
    if(key == KEY1_PRES || flag==1){
        flag = 1;   // KEY1按下flag置1补齐逻辑
        LED0 = 1;   // 灭灯
        return TRUE;
    }
    else return FALSE;
}

int main(void){ 
    u8 key;            // 保存键值
    delay_init(168);   // 初始化延时函数
    LED_Init();        // 初始化LED端口 
    BEEP_Init();       // 初始化蜂鸣器端口
    KEY_Init();        // 初始化与按键连接的硬件接口
    LED0=0;            // 先点亮红灯
 
    while(1){
        key=KEY_Scan(0);    // 得到键值
        if(key){            // 如果键值不为空->若有按键
            switch(key){    
                case WKUP_PRES:     // 上键不操作
                    break;
                case KEY2_PRES:     // 左键不操作
                    break;
                case KEY1_PRES:     // KEY1(下键)灭红灯
                    LED0=1;         // 熄灭LED0(红灯)
                    break;
                case KEY0_PRES:     // KEY0(右键)呼吸灯
                    while(1){       // 循环执行呼吸灯,直至按下下键跳出循环
                        int breath_time_total = 1500;  // 整个周期，1500ms->1.5s->模拟呼吸,吸气呼气各1.5s
                        int breath_time_left = 100;
                        int i;          // 计数器
                        int flag=0;     // 灭灯标记
                        
                        // 亮->暗
                        for(i=breath_time_total; i>breath_time_left; i--){
                            // 若按下KEY1或者KEY1已经按下(flag==1)则熄灯并跳出呼吸循环
                            if(led_off(KEY_Scan(1),flag))   break;  
                            // 亮i us灭breath_time_total+breath_time_left-i ms
                            led_blink(breath_time_total+breath_time_left,i);         
                        }
                        
                        // 若按下KEY1或者KEY1已经按下(flag==1)则熄灯并跳出呼吸循环
                        if(led_off(KEY_Scan(1),flag))   break;  

                        for(i=breath_time_left;i<breath_time_total;i++){
                            // 若按下KEY1则熄灯并跳出暗->亮循环
                            if(led_off(KEY_Scan(1),flag))   break;  
                             // 亮i us灭breath_time_total+breath_time_left-i us
                            led_blink(breath_time_total,i);        
                        }
                        
                        // 若按下KEY1或者KEY1已经按下(flag==1)则熄灯并跳出呼吸循环
                        if(led_off(KEY_Scan(1),flag))   break;  

                    }   // 呼吸灯循环
                    break;  //KEY0 -> case -> break
            }   // 按键判断
        }   // 若有按键
    }   // 整个程序循环体
}   // main()函数
```



----
### 少循环版
- 原理  
  ![20210417193651](http://cdn.ayusummer233.top/img/20210417193651.png)
```C
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "beep.h"
#include "key.h"
typedef enum {FALSE = 0，TRUE = 1} bool；// bool宏定义

/* LED灯闪烁 */
void led_blink(u32 t,u32 bright){
    LED0=0;             // 亮
    delay_ms(bright);   // 保持亮
    LED0=1;             // 暗
    delay_ms(t-bright); // 保持暗
}

/*熄灯判断*/
bool led_off(u8 key, int flag){
  if(key == KEY1_PRES || flag==1){
    flag = 1;   // KEY1按下flag置1补齐逻辑
    LED0 = 1;   // 灭灯
    return TRUE;
  }
  else return FALSE;
}


int main(void){ 
  u8 key;               // 保存键值
  delay_init(168);      // 初始化延时函数
  LED_Init();           // 初始化LED端口 
  BEEP_Init();          // 初始化蜂鸣器端口
  KEY_Init();           // 初始化与按键连接的硬件接口
  LED0=0;               // 先点亮红灯
  
  while(1){
    key=KEY_Scan(0);        // 扫描按键
    // KEY1熄灭LED0
    if(KEY_Scan(1) == KEY1_PRES) LED0=1;  
    // KEY0呼吸灯
    else if(KEY_Scan(1) == KEY0_PRES){
          while(1){
            int flag=0;
            int i;
            int breath_time_total=1500;             // 整个周期，1500ms->1.5s->模拟呼吸,吸气呼气各1.5s
            int breath_single_time=20;              // 人眼可见最短的图像滞留周期即每个周期的时间，20ms
            int breath_times=breath_time_total/breath_single_time;  // 周期数75
            int breath_left_times = 20;             // 呼吸保周期次数,相应的要占满75个周期就要求周期从周期数+保留次数开始
            int breath_times_max = breath_times + breath_left_times;   // 呼吸周期最大次数
            // 周期总数递减->从亮到暗
            for(i=breath_times_max; i>=breath_left_times; i--){        
              // 若按下KEY1或者KEY1已经按下(flag==1)则熄灯并跳出呼吸循环
              if(led_off(KEY_Scan(1),flag))   break;  
              led_blink(breath_single_time, breath_single_time*i/breath_times_max);  //LED灯闪烁
            }
            // 若按下KEY1或者KEY1已经按下(flag==1)则熄灯并跳出呼吸循环
            if(led_off(KEY_Scan(1),flag))   break;  
            // 周期总数自增->breath_times_max,从暗到亮
            for(i=breath_left_times;i<=breath_times_max;i++){       
              // 若按下KEY1或者KEY1已经按下(flag==1)则熄灯并跳出呼吸循环
              if(led_off(KEY_Scan(1),flag))   break;  
              led_blink(breath_single_time,breath_single_time*i/breath_times_max);  //LED灯闪烁
            }
            // 若按下KEY1或者KEY1已经按下(flag==1)则熄灯并跳出呼吸循环
            if(led_off(KEY_Scan(1),flag))   break;  
          } // 呼吸灯循环
    } // KEY0结束
  } // 整个程序循环体
} // main()函数
```
- 实际上flag可以"优化掉;原因在于程序执行速度比较快,那么实际操作过程中按下KEY1键这个动作完全可以覆盖仅仅两个判断的执行时间这样也可以实现KEY1灭灯效果,只不过代码逻辑上不完善
- 比上一版的循环要少许多,性能也要好,不过由于循环次数有限,没有上一版呼吸灯显得那么流畅


----
# 实验5-外部中断实验
- 第4次实验
- [参考链接](https://nosteglic.blog.csdn.net/article/details/108704493)[已失效]

----
## 实验要求
- 不断按下任意按键将产生一个按键序列(不限个数)，当出现KEY0-> KEY0->KEY1->KEY1->KEY2->KEY2-KEY2->KEY_ UP序列时，LED0状态改变。如果没有按这个顺序，则LED0的状态不发生改。
- 011222U (不变)，00011222U (变),00110011222U (变), 001011222U (不变)

---
## 常见问题 & 建议
- ![20210417194411](http:cdn.ayusummer233.top/img/20210417194411.png)
- 原程序中消抖使用的了`delay_ms(10)`,实际效果不好,可以改成`delay_ms(100)`
- 有时候按键按下去可能并没有检测到,可以在中断服务程序中设计按键按下去之后亮个灯或者蜂鸣器响一下之类以便操作时判断按键是否生效


---
## 设计思路
- 状态转换图
  ![20210422103117](http://cdn.ayusummer233.top/img/20210422103117.png)
---
## 实验程序
- 中断服务程序
```C
int width=0;    // 滑动窗口宽度,用于判断LED0是否到了需要改变状态的时候

// 外部中断4服务程序(KEY0,右键)
void EXTI4_IRQHandler(void){
    delay_ms(100);      // 消抖
    if(KEY0==0){
        LED1 = !LED1;    // 测试语句,KEY0按下后LED1反相,用于实测时判断是否检测到了KEY0按下
                     
        if(width == 0 || width == 1) width++;   // 滑窗扩大1格,进入下个状态
        else {                          // width > 1
            if(width == 2);             // width == 2 时再按KEY0滑窗宽度不在增加
            else width=1;               // width > 2  时再按KEY0则滑窗宽度置1
        }
    }         
    EXTI_ClearITPendingBit(EXTI_Line4);    // 清除LINE4上的中断标志位  
}


// 外部中断3服务程序(KEY1,下键)
void EXTI3_IRQHandler(void){
    delay_ms(100);        // 消抖
    if(KEY1==0){
        LED1 = !LED1;   // 测试语句,KEY1按下后LED1反相,用于实测时判断是否检测到了KEY1按下

        if(width == 2 || width == 3) width++;   // 只有2,3两种状态(滑窗宽度)下按下KEY1(下键)才会使滑窗宽度增加
        else width=0;   // 其他情况下按下KEY1(下键)滑窗清零
    }         
    EXTI_ClearITPendingBit(EXTI_Line3);         // 清除LINE3上的中断标志位  
}


// 外部中断2服务程序(KEY2,左键)
void EXTI2_IRQHandler(void){
    delay_ms(100);        // 消抖
    if(KEY2==0){    
        LED1 = !LED1;   // 测试语句,KEY2(左键)按下后LED1反相,用于实测时判断是否检测到了KEY2(左键)按下
        // 当滑窗宽度为4,5,6时按下左键(KEY2)才会使滑窗宽度增加
        if(width == 4 || width == 5 || width == 6 ) width++;    
        else width=0;  // 否则滑窗清零
    }     
    EXTI_ClearITPendingBit(EXTI_Line2); // 清除LINE2上的中断标志位 
}


// 外部中断0服务程序(WK_UP, 上键)
void EXTI0_IRQHandler(void){
    delay_ms(100);        // 消抖
    if(WK_UP==1){       
        LED1 = !LED1;   // 测试语句,WK_UP(上键)按下后LED1反相,用于实测时判断是否检测到了WK_UP(上键)按下
        // 只有当滑窗宽度为7时按下上键(WK_UP)才能滑窗宽度增加,状态达到终态,LED0反相
        if(width==7){
            width++;
            LED0=!LED0;
        }
        // 其它状态下按下上键只会导致滑窗清零
        else width=0; 
    }        
    EXTI_ClearITPendingBit(EXTI_Line0);     // 清除LINE0上的中断标志位 
}    
```


---
# 实验6-独立看门狗实验
- 第5次实验
- [参考链接](https://nosteglic.blog.csdn.net/article/details/108704695)[已失效]

---
## 实验要求
- 1、LED1以呼吸灯指示系统正在运行，如果未及时喂狗，则看门狗发出复位信号，LED1会熄灭(跳闪)
- 2、按键KEY1工作于外部中断方式喂狗;
- 3、在看门狗复位信号产生前进行高频声光报警，即复位前1.5秒左右LED0开始闪烁，同时蜂鸣器间断鸣叫，提示喂狗;报警时呼吸灯不能停止:
- 4、按KEY1喂狗后，报警信息立即全部解除。

----
## 设计思路
- 独立看门狗相关知识
  - ![20210417194840](http://cdn.ayusummer233.top/img/20210417194840.png)
  - ![20210417194858](http://cdn.ayusummer233.top/img/20210417194858.png)

---
### 注意点
- 1.**呼吸灯与看门狗"并行"**
  - `问题阐述` : 由于呼吸灯以及看门狗的实现中都有循环参与(呼吸灯的呼吸循环以及看门狗的报警循环),如果把两处循环分开写,先执行一个循环后执行另一个循环,则看门狗报警时会卡死呼吸灯,导致看门狗报警时呼吸灯状态停止变动
  - `解决方案` : 拆掉一个循环,将其中一个循环的循环体写在其他循环的循环体中;
  - `例如` : 将看门狗的报警判断分别放在呼吸灯的呼吸循环中,循环的每次执行除了闪烁LED1外都会对看门狗报警条件进行判断,若条件成立则相应状态反向一次,然后在执行闪烁函数,利用闪烁函数中的延迟函数实现状态反向后的保持;                                                         

  -----
- 2.**看门狗报警两灯频率以及蜂鸣器频率的调整**
  - `问题阐述` : 如果将一个循环的循环体嵌套在另一个循环的循环体中,那么会导致拆掉的循环体跟着依附循环体的步调走,如果宿主步调太快则会导致从者频率比原本循环快(比如看门狗报警时蜂鸣器和LED0变化频率过高)   
  - `解决方案` : 宿主步调快的话,从者在宿主中可以选择执行,不是宿主每次循环执行从者都执行;  
    - 可以在宿主里的从者代码使用分频,在外部定义一个循环变量,宿主循环每次执行时循环变量都+1,当循环变量等于某个特定值时才执行从者代码;
    - 由于循环变量是循环变化的,因此循环变量的"变化宽度"是几就可以理解成是几分频


---
## 常见问题

---
### 1.变量未定义(如:flag 未定义):
- 有的同学在头文件的对应源文件中做了变量定义,然后在main.c里调用会出现变量未定义
- [解决方案参考链接](https://blog.csdn.net/qq_42681507/article/details/103283506)
- 可以在`exti.h`中声明全局变量flag
  ```C
  extern int flag;
  ```
- 然后在`exti.c`中定义该全局变量
  ```C
  int flag=0;     // 喂狗标志
  ```
- 这样其它导入`exti.h`的源文件就可以使用flag变量了

---
### 2.中断无法判断(关于exti的全报错)
- 比如这种报错:`..\Objects\stm32f103c8t6_all_in_one.axf: Error: L6218E: Undefined symbol EXTI_ClearITPendingBit (ref`
  - [参考链接](https://blog.csdn.net/m0_37135980/article/details/103889881)
- 这是因为本次实验给的模板里面均没有导入中断的头文件与源文件,需要导入对应头文件及源文件
  - ![20210417195316](http://cdn.ayusummer233.top/img/20210417195316.png)
  - ![20210417195335](http://cdn.ayusummer233.top/img/20210417195335.png)
  - ![20210417195359](http://cdn.ayusummer233.top/img/20210417195359.png)

----
## 源码

---
### main.c
```C
/*
 * @Author: your name
 * @Date: 2021-04-29 15:10:00
 * @LastEditTime: 2021-04-29 15:56:59
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \JuniorLesson_SecondTerm\EmbeddedSystem\Experiment\实验6 独立看门狗实验\main-v4.1.1.1-重复代码函数封装.c
 */
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "beep.h"
#include "key.h"
#include "iwdg.h"
#include "exti.h"

// LED闪烁函数
void led_blink(u32 t, u32 bright){
    LED1=0; delay_ms(bright);       // 亮 bright ms
    LED1=1; delay_ms(t-bright);     // 灭 t-bright ms
}

// 循环自增函数 : x->循环自增变量, limit->循环自增上限
int add_circle(int x, int limit){
    return (x+1) % limit;
}

/*
 报警函数(判断及执行)
 (其实功能上并不是报警,仅仅是报警对应LED及蜂鸣器的反相而已,
 结合LED闪烁中的延迟才是完整的报警)
 count 对应报警计数器(可以参考下面主程序里面的count理解其含义)
 div_alarm 对应报警分频循环变量,循环上限为上面add_circle函数中的limit,照理来说这两个函数应该是耦合在一起的
*/
void alarm(int count, int div_alarm){
    // 如果没喂狗,并且"分频成立",那么超时则红灯反相,蜂鸣器反相(用后面的绿灯闪烁来延时)
    if(!flag){
        /* 
          前者对应2个呼吸周期时间;
          后者对应一个报警分频循环计数器的特定值,小于其上限的任意一个值均可;
        */
        if(count>=2 && div_alarm == 4){     
            LED0=!LED0;
            BEEP=!BEEP;
        }
    }
    // 如果喂狗了那么喂狗超时计数器置零,喂狗标志位清零
    else{
        count = 0;
        flag = 0;
    }
}



int main(void){ 
    u16 prer=4;           // 分频系数，预分频系数:4*2^prer=64         
    u16 rlr=500*5;        // 计数重载值       
    u16 count=0;          // 计数变量-用于计算喂狗超时
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);         // 设置系统中断优先级分组2
    delay_init(168);      // 初始化延时函数
    LED_Init();           // 初始化LED端口     
    KEY_Init();           // 初始化按键  
    BEEP_Init();          // 初始化蜂鸣器      
    EXTIX_Init();         // 初始化外部中断输入       

    IWDG_Init(prer,rlr);    // 分频系数为64,重载值为500时,溢出时间为1s
                            // 此实验设计溢出时间为1*5=5s
    LED1=1; delay_ms(100);  // 绿灯(呼吸灯用灯)熄灭100ms-用于指示新一轮看门狗计时开始         

    while(1){           
        int i;                  // 计数器
        int div_alarm = 0;      // 定义报警分频变量
        int totaltime=1000; 
        int shorttime=20;
        int circle=totaltime/shorttime;
        
        // 亮->暗
        for(i=circle; i>=5; i--){  
            // 报警分频变量循环, 第二个参数为自增上限
            div_alarm = add_circle(div_alarm, 5);
            // 报警判断及执行
            alarm(count, div_alarm);
            // LED闪烁->呼吸灯
            led_blink(shorttime,shorttime*i/circle);
        }
        
        // 暗->亮
        for( ; i<=circle; i++){
            // 报警分频变量循环, 第二个参数为自增上限
            div_alarm = add_circle(div_alarm, 5);
            alarm(count, div_alarm);
            led_blink(shorttime,shorttime*i/circle);
        }
        
        // 一轮呼吸之后喂狗超时计数器+1
        count++;
    };

}
```


----
# 实验8-基本定时器实验
- 第6次实验
- [参考链接](https://nosteglic.blog.csdn.net/article/details/108704934)[已失效]

----
## 实验内容
- 用定时器3中断方式控制LED0和LED1的闪烁频率；
- KEY0、KEY1和KEY2工作于中断方式；
- 用按键KEY0控制LED0启动闪烁，再按一次则LED0停止闪烁，熄灭；
- 用按键KEY1控制LED1启动闪烁，再按一次则LED1停止闪烁，熄灭；
- 如果LED0或LED1在闪烁，按KEY2会点亮LED0或LED1(原来闪烁的停止)，这时按KEY0或KEY1不发生任何改变；再按下KEY2后，恢复原来的状态，即闪烁的继续闪烁，熄灭的依然熄灭。


----
## 注意事项
- 改变闪烁频率
  ```
  TIM3_Int_Init(arr-1,psc-1);    // 改变计数值arr和分频系数psc
  ```

  ----
- `u8`：`unsigned char`
- `u16`、`u32`：`整型`

  ---
- 原项目中没有使用到,但是当前项目使用到的源码记得加
  ![20210428224744](http://cdn.ayusummer233.top/img/20210428224744.png)   
  ![20210428224839](http://cdn.ayusummer233.top/img/20210428224839.png)

---
## 源码

---
### exti.c
```C
#include "exti.h"
#include "delay.h" 
#include "led.h" 
#include "key.h"
#include "timer.h"
//////////////////////////////////////////////////////////////////////////////////     
//本程序只供学习使用，未经作者许可，不得用于其它任何用途
//ALIENTEK STM32F407开发板
//外部中断 驱动代码       
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//创建日期:2014/5/4
//版本：V1.0
//版权所有，盗版必究。
//Copyright(C) 广州市星翼电子科技有限公司 2014-2024
//All rights reserved                                      
////////////////////////////////////////////////////////////////////////////////// 

int en_key0=0;          // key0按键有效性, 0->无效, 1->有效->LED0闪烁
int en_key1=0;          // key1按键有效性, 0->无效, 1->有效
int key2_lock_en=0;     // key2用于上锁,有效性, 0->无效, 1->有效->给lED和右键下键上锁,LED状态固定且右下键无法再控制LED状态

int LED0_origin=1;      // LED0原来值(按下Key2前的值)->用于交替闪烁保持
int LED1_origin=1;      // LED1原来值(按下Key2前的值)->用于交替闪烁保持

// 外部中断4服务程序(KEY0, 右键)
void EXTI4_IRQHandler(void){
    delay_ms(100);                   // 消抖
    if(KEY0==0 && (!key2_lock_en))   // 按KEY0且未按下KEY2
        en_key0 = !en_key0;          // KEY0按键状态改变
    EXTI_ClearITPendingBit(EXTI_Line4);    // 清除LINE4上的中断标志位  
}


// 外部中断3服务程序(KEY1, 下键)
void EXTI3_IRQHandler(void){
    delay_ms(100);                  // 消抖
    if(KEY1==0&&(!key2_lock_en))    // 按KEY1且未按下KEY2
        en_key1=!en_key1;           // KEY1按键状态改变
    EXTI_ClearITPendingBit(EXTI_Line3);    // 清除LINE3上的中断标志位  
}


// 外部中断2服务程序(KEY2, 左键)
void EXTI2_IRQHandler(void){
    delay_ms(100);    // 消抖

    // 若KEY2按下
    if(KEY2 == 0){
        key2_lock_en =! key2_lock_en;     // KEY2按下的标志位反相
        // 如果KEY2按下则给当前LED状态上锁
        if(key2_lock_en){     
          // 将LED状态送给旧值
          LED0_origin=LED0;    
          LED1_origin=LED1;
          // 如果LED在闪烁则将其置为常亮, 若熄灭则不变
          if(en_key0) LED0=0;     // en_key0为1时，LED0正在闪烁，设置成常亮
          if(en_key1) LED1=0;
          
          TIM_Cmd(TIM3,DISABLE);    // 失能TIM3
        }
        // 如果KEY2上锁无效(解锁)
        else{
          // LED状态返回旧值
          LED0=LED0_origin;             
          LED1=LED1_origin;
          TIM_Cmd(TIM3,ENABLE);     // 使能TIM3
        }    
    }         
    EXTI_ClearITPendingBit(EXTI_Line2);//清除LINE2上的中断标志位 
}


//外部中断0服务程序
void EXTI0_IRQHandler(void){
    delay_ms(10);    //消抖
    if(WK_UP==1){
      // do nothing
    }         
    EXTI_ClearITPendingBit(EXTI_Line0); //清除LINE0上的中断标志位 
}    

       
//外部中断初始化程序
//初始化PE2~4,PA0为中断输入.
void EXTIX_Init(void){
    NVIC_InitTypeDef   NVIC_InitStructure;
    EXTI_InitTypeDef   EXTI_InitStructure;
    
    KEY_Init(); //按键对应的IO口初始化
 
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);  // 使能SYSCFG时钟
    
 
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource2); // PE2 连接到中断线2
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource3); // PE3 连接到中断线3
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource4); // PE4 连接到中断线4
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource0); // PA0 连接到中断线0
    
    /* 配置EXTI_Line0 */
    EXTI_InitStructure.EXTI_Line = EXTI_Line0;              // LINE0
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;     // 中断事件
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  // 上升沿触发 
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;               // 使能LINE0
    EXTI_Init(&EXTI_InitStructure);                         // 配置
      
    /* 配置EXTI_Line2,3,4 */
    EXTI_InitStructure.EXTI_Line = EXTI_Line2 | EXTI_Line3 | EXTI_Line4;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;       // 中断事件
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;   //下降沿触发
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;                 // 中断线使能
    EXTI_Init(&EXTI_InitStructure);                           // 配置
  
    NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;              // 外部中断0
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;  // 抢占优先级0
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;         // 子优先级2
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;               // 使能外部中断通道
    NVIC_Init(&NVIC_InitStructure);                               //配置
      
    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;              // 外部中断2
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x03;  // 抢占优先级3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;         // 子优先级2
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;               // 使能外部中断通道
    NVIC_Init(&NVIC_InitStructure);                               // 配置
      
      
    NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;              // 外部中断3
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;  // 抢占优先级2
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;         // 子优先级2
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;               // 使能外部中断通道
    NVIC_Init(&NVIC_InitStructure);                               // 配置
      
      
    NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;              // 外部中断4
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x01;  // 抢占优先级1
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;         // 子优先级2
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;               // 使能外部中断通道
    NVIC_Init(&NVIC_InitStructure);                               // 配置
}
```
---
### timer.c
```C
/*
 * @Author: your name
 * @Date: 2021-04-22 19:46:27
 * @LastEditTime: 2021-05-12 15:49:27
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \JuniorLesson_SecondTerm\EmbeddedSystem\Experiment\实验8-第6次实验-定时器中断实验\timer-v3.0-lc.c
 */
#include "timer.h"
#include "led.h"
//////////////////////////////////////////////////////////////////////////////////     
//本程序只供学习使用，未经作者许可，不得用于其它任何用途
//ALIENTEK STM32F407开发板
//定时器 驱动代码       
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//创建日期:2014/5/4
//版本：V1.0
//版权所有，盗版必究。
//Copyright(C) 广州市星翼电子科技有限公司 2014-2024
//All rights reserved                                      
//////////////////////////////////////////////////////////////////////////////////      
extern int en_key0;   // KEY0按键是否生效 : 1->生效->LED0闪烁
extern int en_key1;   // KEY1是否生效 : 1->生效

//通用定时器3中断初始化
//定时器溢出时间计算方法:Tout=((arr+1)*(psc+1))/Ft us.
//Ft=定时器工作频率,单位:Mhz
//这里使用的是定时器3!

void TIM3_Int_Init(u16 arr,u16 psc){
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;
    
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);  // 使能TIM3时钟
    
      TIM_TimeBaseInitStructure.TIM_Period = arr;         // 自动重装载值
    TIM_TimeBaseInitStructure.TIM_Prescaler=psc;          // 定时器分频, 时钟预分频数
    TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up;     // 向上计数模式
    TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; 
    
    TIM_TimeBaseInit(TIM3,&TIM_TimeBaseInitStructure);    // 初始化TIM3
    
    TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE);             // 允许定时器3更新中断
    TIM_Cmd(TIM3,ENABLE);     // 使能定时器3
    
    NVIC_InitStructure.NVIC_IRQChannel=TIM3_IRQn;         // 定时器3中断
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0x01;     // 抢占优先级1
    NVIC_InitStructure.NVIC_IRQChannelSubPriority=0x03;         // 子优先级3
    NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;
    NVIC_Init(&NVIC_InitStructure);
    
}

// 定时器3中断服务函数
void TIM3_IRQHandler(void){
    if(TIM_GetITStatus(TIM3,TIM_IT_Update)==SET){    // 溢出中断
        if(en_key1) LED1=!LED1; // LED1(绿灯)反相
        else LED1=1;
        if(en_key0) LED0=!LED0; // LED0(红灯)反相
        else LED0=1;
    }
    TIM_ClearITPendingBit(TIM3,TIM_IT_Update);  //清除中断标志位
}
```
----
### main.c
```C
/*
 * @Author: your name
 * @Date: 2021-04-22 19:47:42
 * @LastEditTime: 2021-04-28 22:43:43
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \JuniorLesson_SecondTerm\EmbeddedSystem\Experiment\实验8-第6次实验-定时器中断实验\main-v3.0-lc.c
 */
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "timer.h"
#include "exti.h"



//ALIENTEK 探索者STM32F407开发板 实验8
//定时器中断实验-库函数版本
//技术支持：www.openedv.com
//淘宝店铺：http://eboard.taobao.com
//广州市星翼电子科技有限公司  
//作者：正点原子 @ALIENTEK  
int main(void){ 
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置系统中断优先级分组2
    delay_init(168);    // 初始化延时函数
    LED_Init();         // 初始化LED端口
    EXTIX_Init();       // 初始化外部中断输入
    // 定时器时钟84M，分频系数8400，所以84M/8400=10Khz的计数频率，计数5000次为500ms 
    TIM3_Int_Init(5000-1,8400-1);        
    while(1){
        // do nothing
    };
}
```

---
# 实验9-PVM输出实验
- 第7次实验

----
## 实验内容
- 1. 实现用正弦波的数值控制LED0闪烁；
- 2. 同时将该控制量送串口输出正弦波波形；
- 3. 用KEY0中断方式控制启动和停止。
    - （1）按下KEY0，LED0开始闪烁，串口输出波形。
    - （2）再次按下KEY0，LED0和输出波形都暂停；
    - （3）第三次按KEY0，LED0和输出波形都能恢复，并和原来的状态衔接上，即保持闪烁的完整性和波形的完整性。
- 4. 特别重要： 中途重启计算机或做完实验关机时，必须下载一个其他程序到实验板中，比如实验二跑马灯；或者运行桌面的FlyMCU，点击清除芯片功能。否则重启计算机后鼠标可能工作不正常。

----
## 源码

---
### exti.c
```C
#include "exti.h"
#include "delay.h" 
#include "led.h" 
#include "key.h"

    
//////////////////////////////////////////////////////////////////////////////////     
//本程序只供学习使用，未经作者许可，不得用于其它任何用途
//ALIENTEK STM32F407开发板
//外部中断 驱动代码       
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//创建日期:2014/5/4
//版本：V1.0
//版权所有，盗版必究。
//Copyright(C) 广州市星翼电子科技有限公司 2014-2024
//All rights reserved                                      
////////////////////////////////////////////////////////////////////////////////// 

int Flag=0;

//外部中断4服务程序(KEY0, 右键)
void EXTI4_IRQHandler(void){
    delay_ms(100);    // 消抖
    if(KEY0==0)     Flag=!Flag;
    EXTI_ClearITPendingBit(EXTI_Line4);    // 清除LINE4上的中断标志位  
}

//外部中断0服务程序
void EXTI0_IRQHandler(void)
{
    /*
    delay_ms(10);    //消抖
    if(WK_UP==1)     
    {
        int a=1;
        a=a<<i;
        i++;
        key_up=a;
    }         
     EXTI_ClearITPendingBit(EXTI_Line0); //清除LINE0上的中断标志位 
    */
}    

//外部中断2服务程序
void EXTI2_IRQHandler(void)
{
    /*
    delay_ms(10);    //消抖
    if(KEY2==0)      
    {            
    int b=1;
        b=b<<i;
        i++;
        key2=b;
    }         
     EXTI_ClearITPendingBit(EXTI_Line2);//清除LINE2上的中断标志位 
    */
}
//外部中断3服务程序
void EXTI3_IRQHandler(void)
{
    /*
    delay_ms(10);    //消抖
    if(KEY1==0)     
    {
        int c=1;
        c=c<<i;
        i++;
        key1=c;
    }         
     EXTI_ClearITPendingBit(EXTI_Line3);  //清除LINE3上的中断标志位  
    */
}


       
//外部中断初始化程序
//初始化PE2~4,PA0为中断输入.
void EXTIX_Init(void)
{
    NVIC_InitTypeDef   NVIC_InitStructure;
    EXTI_InitTypeDef   EXTI_InitStructure;
    
    KEY_Init(); //按键对应的IO口初始化
 
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);//使能SYSCFG时钟
    
 
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource2);//PE2 连接到中断线2
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource3);//PE3 连接到中断线3
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource4);//PE4 连接到中断线4
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource0);//PA0 连接到中断线0
    
  /* 配置EXTI_Line0 */

    EXTI_InitStructure.EXTI_Line = EXTI_Line0;//LINE0
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;//中断事件
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; //上升沿触发 
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;//使能LINE0
  EXTI_Init(&EXTI_InitStructure);//配置
    

    /* 配置EXTI_Line2,3,4 */
    
    EXTI_InitStructure.EXTI_Line = EXTI_Line2 | EXTI_Line3 | EXTI_Line4;
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;//中断事件
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; //下降沿触发
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;//中断线使能
  EXTI_Init(&EXTI_InitStructure);//配置
    
 
    NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;//外部中断0
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;//抢占优先级0
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;//子优先级2
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//使能外部中断通道
  NVIC_Init(&NVIC_InitStructure);//配置
    
    
    
    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;//外部中断2
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x03;//抢占优先级3
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;//子优先级2
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//使能外部中断通道
  NVIC_Init(&NVIC_InitStructure);//配置
    
    
    NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;//外部中断3
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;//抢占优先级2
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;//子优先级2
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//使能外部中断通道
  NVIC_Init(&NVIC_InitStructure);//配置
    
    
    NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;//外部中断4
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x01;//抢占优先级1
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;//子优先级2
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//使能外部中断通道
  NVIC_Init(&NVIC_InitStructure);//配置
    
       
}
```
---
### exti.h
```C
#ifndef __EXTI_H
#define __EXIT_H     
#include "sys.h"      

//////////////////////////////////////////////////////////////////////////////////     
//本程序只供学习使用，未经作者许可，不得用于其它任何用途
//ALIENTEK STM32F407开发板
//外部中断 驱动代码       
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//创建日期:2014/5/4
//版本：V1.0
//版权所有，盗版必究。
//Copyright(C) 广州市星翼电子科技有限公司 2014-2024
//All rights reserved                                      
//////////////////////////////////////////////////////////////////////////////////      

extern int Flag;        // Flag外部定义

void EXTIX_Init(void);    // 外部中断初始化                                 
#endif
```

---
### main.c
```C
/*
 * @Author: your name
 * @Date: 2021-04-29 19:39:15
 * @LastEditTime: 2021-04-29 19:55:28
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \JuniorLesson_SecondTerm\EmbeddedSystem\Experiment\实验9-第7次实验-PWM输出实验\main-v2.0.c
 */
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "pwm.h"
#include "math.h"
#include "exti.h"

//ALIENTEK 探索者STM32F407开发板 实验9
//PWM输出实验-库函数版本
//技术支持：www.openedv.com
//淘宝店铺：http://eboard.taobao.com  
//广州市星翼电子科技有限公司  
//作者：正点原子 @ALIENTEK
//extern int Flag;

#define  PI 3.1415926

int main(void){ 
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置系统中断优先级分组2
    delay_init(168);      // 初始化延时函数
    uart_init(115200);    // 初始化串口波特率为115200
    EXTIX_Init();
    TIM14_PWM_Init(500-1,84-1);        // a84M/84=1Mhz的计数频率,重装载值500，所以PWM频率为 1M/500=2Khz.     
    
    int i=0,x=1;
    u16 led0pwmval=0; 
       
       while(1){ 
        delay_ms(100);    // 消抖     
        if(!Flag){
            printf("       ");
            if(x>=16){
                for(i=0; i<led0pwmval/5; i++)  printf("*"); 
                printf("\r\n");
            }
            else{
                for(i=0; i<led0pwmval/5;i++)    printf(" "); 
                printf("*\r\n");
            }
            
            if(x<16)    x++;
            else x=1;     // 1-16

            led0pwmval=300*sin(2*x*PI/64);
            
        TIM_SetCompare1(TIM14, led0pwmval);    // 修改比较值，修改占空比
        }
    }    
}
```



-----
# 实验4-USART实验
- 第8次实验
- 对应正点原子的`STM32F4开发指南_库函数版本`第九章-串口通信实验

----
## 实验内容
- 1.按下计算机键盘按键能立即回显到串口调试助手的窗口中；
  - 串口助手不能使用定时发送和自动回显功能；
- 2.如果依次按下指定序列“123a456b789c”，则在按下“c”时点亮LED0，否则熄灭。        

----
## 注意事项
- 使用微软商店中的串口调试助手时参数配置可参考下图:
  ![20210513170045](http://cdn.ayusummer233.top/img/20210513170045.png)
- 需要取消时间戳


----
## Tips

----
### #if,#endif
- #if的后面接的是表达式，条件语句
- #if的具体作用是，如果满足条件语句，则**编译器会把#if与#endif之间的代码编译进去。此处只编译，不执行**。


----
## 源码

---
### usart.c
```C
/*
 * @Author: your name
 * @Date: 2021-05-13 17:06:32
 * @LastEditTime: 2021-06-03 19:48:36
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \JuniorLesson_SecondTerm\EmbeddedSystem\Experiment\实验4-第8次实验-串口(usart)实验\usart-v1.0-初次尝试.c
 */
#include "sys.h"
#include "usart.h"   
#include "led.h" 
//////////////////////////////////////////////////////////////////////////////////      
//如果使用ucos,则包括下面的头文件即可.
#if SYSTEM_SUPPORT_OS
#include "includes.h"                    //ucos 使用      
#endif

//////////////////////////////////////////////////////////////////////////////////     
//本程序只供学习使用，未经作者许可，不得用于其它任何用途
//ALIENTEK STM32F4探索者开发板
//串口1初始化           
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//修改日期:2014/6/10
//版本：V1.5
//版权所有，盗版必究。
//Copyright(C) 广州市星翼电子科技有限公司 2009-2019
//All rights reserved
//********************************************************************************
//V1.3修改说明 
//支持适应不同频率下的串口波特率设置.
//加入了对printf的支持
//增加了串口接收命令功能.
//修正了printf第一个字符丢失的bug
//V1.4修改说明
//1,修改串口初始化IO的bug
//2,修改了USART_RX_STA,使得串口最大接收字节数为2的14次方
//3,增加了USART_REC_LEN,用于定义串口最大允许接收的字节数(不大于2的14次方)
//4,修改了EN_USART1_RX的使能方式
//V1.5修改说明
//1,增加了对UCOSII的支持
//////////////////////////////////////////////////////////////////////////////////       
 

//////////////////////////////////////////////////////////////////
//加入以下代码,支持printf函数,而不需要选择use MicroLIB      
#if 1
#pragma import(__use_no_semihosting)             
//标准库需要的支持函数                 
struct __FILE{ 
    int handle; 
}; 

FILE __stdout;       
//定义_sys_exit()以避免使用半主机模式    
void _sys_exit(int x){ 
    x = x; 
} 
//重定义fputc函数 
int fputc(int ch, FILE *f){     
    while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
    USART1->DR = (u8) ch;      
    return ch;
}
#endif
 
#if EN_USART1_RX   //如果使能了接收

// 串口1中断服务程序
// 注意,读取USARTx->SR能避免莫名其妙的错误       

u8 USART_RX_BUF[USART_REC_LEN];     // 接收缓冲,最大USART_REC_LEN个字节.

//接收状态
//bit15，    接收完成标志
//bit14，    接收到0x0d
//bit13~0，    接收到的有效字节数目

u16 USART_RX_STA=0;       //接收状态标记    

//初始化IO 串口1 
//bound:波特率
void uart_init(u32 bound){
   //GPIO端口设置
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;
    
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE); //使能GPIOA时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);//使能USART1时钟
 
    //串口1对应引脚复用映射
    GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_USART1); //GPIOA9复用为USART1
    GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_USART1); //GPIOA10复用为USART1
    
    //USART1端口配置
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10; //GPIOA9与GPIOA10
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    //速度50MHz
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; //推挽复用输出
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; //上拉
    GPIO_Init(GPIOA,&GPIO_InitStructure); //初始化PA9，PA10

   //USART1 初始化设置
    USART_InitStructure.USART_BaudRate = bound;//波特率设置
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
    USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
    USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;    //收发模式
    USART_Init(USART1, &USART_InitStructure); //初始化串口1
    
    USART_Cmd(USART1, ENABLE);  //使能串口1 
    
    //USART_ClearFlag(USART1, USART_FLAG_TC);
    
#if EN_USART1_RX    
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);      // 开启相关中断

    //Usart1 NVIC 配置
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;   // 串口1中断通道
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3;     // 抢占优先级3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority =3;           // 子优先级3
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;             // IRQ通道使能
    NVIC_Init(&NVIC_InitStructure);    // 根据指定的参数初始化VIC寄存器、

#endif
    
}



char C[12]={'1','2','3','a','4','5','6','b','7','8','9','c'}; 
u8 index=0;
void USART1_IRQHandler(void){
    u8 Res;

    #if SYSTEM_SUPPORT_OS         
        OSIntEnter();    
    #endif

    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET){
        Res =USART_ReceiveData(USART1);
        USART_SendData(USART1,Res);
        
        if(Res==C[index])
            index++;
        else{
            if(Res=='1') 
              index=1;
            else
              index=0;
        }
        
        if(index==12){ 
            LED0=0;    
            index=0;  
        }
        else LED0=1;
    }
         
    #if SYSTEM_SUPPORT_OS 
        OSIntExit();                                               
    #endif
} 

#endif    
```

---
### main.c
```C
/*
 * @Author: your name
 * @Date: 2021-05-13 18:57:37
 * @LastEditTime: 2021-05-13 19:02:13
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \JuniorLesson_SecondTerm\EmbeddedSystem\Experiment\实验4-第8次实验-串口(usart)实验\main-v1.0-初次尝试.c
 */
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "beep.h"
#include "key.h"


//ALIENTEK 探索者STM32F407开发板 实验4
//串口通信实验 -库函数版本
//技术支持：www.openedv.com
//淘宝店铺：http://eboard.taobao.com
//广州市星翼电子科技有限公司  
//作者：正点原子 @ALIENTEK


int main(void){ 
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);     // 设置系统中断优先级分组2
    delay_init(168);        // 延时初始化 
    uart_init(115200);        // 串口初始化波特率为115200
    LED_Init();                  // 初始化与LED连接的硬件接口  
    while(1){
        // do nothing
    }
}
```


----
# 实验18-ADC实验
- 第9次实验

---
## 实验内容
 - 在开发板的LCD上画出电压的波形。
 - 注意：
   - 1.波形反映的是电压的波动，比例可以自己决定，但要波动看上去比较明显；
   - 2.开始的时候波形是向右延伸，而满屏后应该让图形滚动起来。

----
## 函数用法概览
- ```C
  // 画线
  // x1,y1 : 起点坐标
  // x2,y2 : 终点坐标  
  void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2);
  ```
  - 实际视觉上,变量中的10对应实验板LCD屏上约1mm


----
- ```C
  // 显示字符串
  // x,y : 起点坐标
  // width,height : 区域大小  
  // size : 字体大小
  // *p : 字符串起始地址          
  void LCD_ShowString(u16 x,u16 y,u16 width,u16 height,u8 size,u8 *p);
  ```

  ----
- ```C
  //显示数字,高位为0,还是显示
  //x,y:起点坐标
  //num:数值(0~999999999);     
  //len:长度(即要显示的位数)
  //size:字体大小
  //mode:
  //[7]:0,不填充;1,填充0.
  //[6:1]:保留
  //[0]:0,非叠加显示;1,叠加显示.
  void LCD_ShowxNum(u16 x,u16 y,u32 num,u8 len,u8 size,u8 mode);
  ```

  ---
- ```C
  //在指定区域内填充单个颜色
  //(sx,sy),(ex,ey):填充矩形对角坐标,区域大小为:(ex-sx+1)*(ey-sy+1)   
  //color:要填充的颜色
  void LCD_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 color);
  ```

---
## 调试记录

---
### STM32常见错误error: #268: declaration may not appear after executable statement in block
- 声明不能在可执行语句后出现。表示有变量在函数后面声明，应该改为在函数开头声明变量。
- 因为 keil 默认编译标准是C89，解决方法：  
  ![20210520164727](http://cdn.ayusummer233.top/img/20210520164727.png)

---
## 源码

---
### main.c
```C
/*
 * @Author: your name
 * @Date: 2021-05-20 17:31:33
 * @LastEditTime: 2021-05-20 18:54:46
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \JuniorLesson_SecondTerm\EmbeddedSystem\Experiment\实验18-第9次实验-ADC实验\main-v1.1.1.1-滚动函数调整.c
 */
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "lcd.h"
#include "adc.h"


//ALIENTEK 探索者STM32F407开发板 实验18
//ADC模数转换实验-库函数版本  
//技术支持：www.openedv.com
//淘宝店铺：http://eboard.taobao.com  
//广州市星翼电子科技有限公司  
//作者：正点原子 @ALIENTEK

#define front_axisX 30      // x轴与边界的距离(x轴起点)
#define length_axis_x  400  // x轴长度为40mm
int tail_axisX = length_axis_x + front_axisX;   // x轴尾部横坐标

#define length_axis_y  400  // y轴长度为20mm



#define num_point_per_circle 20      // 每轮周期中的点的数目
int distance_between_two_point = length_axis_x / num_point_per_circle;  // 两点间距

#define distance_plumb_arrow 5          // 箭头与坐标轴的铅垂线距离
#define distance_horizontal_arrow 15    // 箭头与坐标轴端点水平距离


#define minus 30    // 
#define time_zoom_in 5                  // 电压差异放大倍数
#define Make_up_the_difference_vol -100 // y轴电压补差

#define x_begin_point 30                // 起始点横坐标
#define y_begin_point lcddev.height/2   // 起始点纵坐标

u16 buffer[num_point_per_circle];   // 电压缓冲数组
static int index=0;   // 电压缓冲数组下标(循环自增的数组下标)
u16 x1,x2,y1,y2;    // 定义横纵坐标

/*滚动，双标记位实现循环数组*/
void draw_roll(u16 buffer[], u16 temp){
    index = index%num_point_per_circle; 
    buffer[index]=temp;     // 赋值给当前索引值
    int tail_index_draw = index;    // 绘制结束索引
    index++;
    int index_draw = index;     // 绘制索引(起始)

    
    // 起绘点定义
    x1=30;
    y1=buffer[index_draw];
    
    while(1){ 
        // 绘制索引循环自增
        index_draw = (index_draw+1)%num_point_per_circle;

        /* 绘制 */
        x2 = x1+distance_between_two_point;
        y2 = buffer[index_draw];
        LCD_DrawLine(x1,y1,x2,y2);
        
        /* 下条绘制线迭代 */
        x1=x2;
        y1=y2;

        if(index_draw == tail_index_draw) break;
    }
    delay_ms(500);
}


/* 局部清屏，避免抖动
   //在指定区域内填充单个颜色
  LCD_Fill(填充矩形对角坐标, 要填充的颜色);*/
void clean_lcd(void){
    LCD_Fill(31, lcddev.height/2-150, 435, lcddev.height/2+95, WHITE);    
}



int main(void){ 
    u16 adcx;       // 存放adc值 
    float temp;     // 暂存adc值
    int count=0;    // 用于判断是否是第一轮画线
    
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);     // 设置系统中断优先级分组2
    delay_init(168);        // 初始化延时函数
    uart_init(115200);      // 初始化串口波特率为115200
    LED_Init();             // 初始化LED 
    LCD_Init();             // 初始化LCD
    Adc_Init();             // 初始化ADC
    
    POINT_COLOR=RED;        // 画笔设为红色

    /*在屏幕正中偏下方显示电压值*/
    LCD_ShowString(lcddev.width*2/5, lcddev.height*9/10, 200,16,16,"ADC=0.000V");

    int up_axisY =  lcddev.height/2 - length_axis_y/2;  // y轴上端
    int down_axisY = lcddev.height/2 + length_axis_y/2;  // y轴下端
    /* x，y轴显示
       LCD_DrawLine(x1, y1, x2, y2)   // 画线(起点坐标,终点坐标) */
    LCD_DrawLine( front_axisX,  down_axisY, front_axisX, up_axisY);      // y轴
    LCD_DrawLine( front_axisX,  down_axisY, tail_axisX,  down_axisY);    // x轴
    // y轴箭头左半(y轴顶点->箭头尾)
    LCD_DrawLine( front_axisX,  up_axisY, 
                  front_axisX - distance_plumb_arrow, up_axisY + distance_horizontal_arrow);    
    // y轴箭头右半(y轴顶点->箭头尾)
    LCD_DrawLine( front_axisX,  up_axisY, 
                  front_axisX + distance_plumb_arrow, up_axisY + distance_horizontal_arrow);     
    // x轴箭头上半(x轴顶点->箭头尾)
    LCD_DrawLine( tail_axisX, down_axisY, 
                  tail_axisX - distance_horizontal_arrow, down_axisY - distance_plumb_arrow);   
    // x轴箭头下半(x轴顶点->箭头尾)   
    LCD_DrawLine( tail_axisX, down_axisY, 
                  tail_axisX - distance_horizontal_arrow, down_axisY + distance_plumb_arrow);      
    LCD_ShowString(0,          up_axisY,     200,16, 16, "VOL");     // y轴标注 VOL   
    LCD_ShowString(tail_axisX, down_axisY+5, 200,16, 16, "TIME");    // x轴标注 TIME
    
    /*初始化第一个点*/
    x1 = x_begin_point;
    y1 = y_begin_point;
    
    while(1){
        adcx=Get_Adc_Average(ADC_Channel_5,20);     // 获取通道5的转换值，20次取平均 about 3835~3837
        temp=(float)adcx*(3.3/4096);                // 获取计算后的带小数的实际电压值，比如3.1111
        
        /*显示整数 LCD_ShowxNum(起点坐标, 数值, 长度也即要显示的位数, 字体大小, mode)*/
        adcx=temp;      // 赋值整数部分给adcx变量，因为adcx为u16整形
        LCD_ShowxNum(32+lcddev.width*2/5, lcddev.height*9/10, adcx, 1,16, 0);
        
        /*显示小数*/
        temp -= adcx;       // 去整
        temp = temp*1000;   // 小数部分转整数
        // 显示小数部分
        LCD_ShowxNum(47+lcddev.width*2/5, lcddev.height*9/10,temp, 3, 16, 0x80);    
        
        // 第一轮
        if(count<num_point_per_circle){                            
            x2 = x1 + distance_between_two_point;       // 每隔 distance_between_two_point 画一个像素点
            y2= temp*time_zoom_in + Make_up_the_difference_vol;       // 放大电压差异
            buffer[index]=y2;                          // 电压缓冲区
            index++;
            count++;
            LCD_DrawLine(x1,y1,x2,y2);
            x1=x2;
            y1=y2;
        }
        
        if(count==num_point_per_circle){                            //不是第一轮
            clean_lcd();                          //清屏
            temp= temp*time_zoom_in + Make_up_the_difference_vol;  //放大电压差异
            draw_roll(buffer,temp);               //滚动
        }
    }//while(1)
}
```

---
# 实验20-DAC实验
- 第10次实验

---
## 实验内容
- 1、用正弦波数值作为DAC数据保持寄存器的输入值:在液晶屏上显示该数值:
- 2、DAC输出连接到ADC输入;
- 3、DAC输入值和ADC输出值转换为电压数据在液晶屏上显示:
- 4、ADC输出用波形在液晶屏上显示，波形颜色与坐标轴颜色不能相同。
> 提示: Get Adc Average中的延时可以改为1ms

![20210623105659](http://cdn.ayusummer233.top/img/20210623105659.png)


---
## 源码

---
### main.c
```C
     /*
 * @Author: your name
 * @Date: 2021-05-27 19:26:36
 * @LastEditTime: 2021-06-03 17:45:53
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \JuniorLesson_SecondTerm\EmbeddedSystem\Experiment\实验20-第10次实验-DAC实验\main-v2.0-初次尝试.c
 */
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "lcd.h"
#include "adc.h"
#include "dac.h"
#include "key.h"
#include <cmath>

//ALIENTEK 探索者STM32F407开发板 实验21
//DAC实验-库函数版本
//技术支持：www.openedv.com
//淘宝店铺：http://eboard.taobao.com  
//广州市星翼电子科技有限公司  
//作者：正点原子 @ALIENTEK

#define Pi 3.14 
int main(void){ 
    int i2=0;
    double rad=Pi/180;
    u16 adcx;
    float temp;
    u8 t=0;     
    u16 dacval=0;
    // u8 key;    
    u16 adc[80];
    float temp1;
    float temp2;
    int i=0;
    int j;

    // 设置系统中断优先级分组2
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    delay_init(168);    // 初始化延时函数
    uart_init(115200);  // 初始化串口波特率为115200
    
    LED_Init();         // 初始化LED 
    LCD_Init();         // LCD初始化
    Adc_Init();         // adc初始化
    KEY_Init();         // 按键初始化
    Dac1_Init();        // DAC通道1初始化    
    POINT_COLOR=RED; 
    
    LCD_ShowString(30,50,200,16,16,"Explorer STM32F4");    
    LCD_ShowString(30,70,200,16,16,"DAC TEST");    
    LCD_ShowString(30,90,200,16,16,"ATOM@ALIENTEK");
    LCD_ShowString(30,110,200,16,16,"2014/5/6");     
    LCD_ShowString(30,130,200,16,16,"WK_UP:+  KEY1:-");     
    
    // 电压值显示
    POINT_COLOR=BLUE;       // 设置字体为蓝色             
    LCD_ShowString(30,150,200,16,16,"DAC VAL:");          
    LCD_ShowString(30,170,200,16,16,"DAC VOL:0.000V");          
    LCD_ShowString(30,190,200,16,16,"ADC VOL:0.000V");
    
    // y轴, 箭头, 标注
    LCD_DrawLine(50,320,50,500);    
    LCD_DrawLine(50,320,45,335);    
    LCD_DrawLine(50,320,55,335);
    LCD_ShowString(70,320,200,16,16,"VOL");

    // x轴, 箭头, 标注
    LCD_DrawLine(50,500,300,500);
    LCD_DrawLine(300,500,285,495);
    LCD_DrawLine(300,500,285,505);
    LCD_ShowString(305,515,200,16,16,"TIME");    
       
    while(1){
        if(i2>=360) 
            i2=0;    
        i2=i2+5;
        
        // 设置初始值
        dacval=(int)(sin(i2*rad)*500+600);    
        DAC_SetChannel1Data(DAC_Align_12b_R, dacval);

        POINT_COLOR=BLUE;
        // 读取前面设置DAC的值
        adcx=DAC_GetDataOutputValue(DAC_Channel_1);
        LCD_ShowxNum(94,150,adcx,4,16,0);   // 显示DAC寄存器值
        temp=(float)adcx*(3.3/4096);        // 得到DAC电压值
        adcx=temp;
        LCD_ShowxNum(94,170,temp,1,16,0);   // 显示电压值整数部分
        // 显示电压值的小数部分
        temp-=adcx;
        temp*=1000;
        LCD_ShowxNum(110,170,temp,3,16,0X80);        

         
        adcx=Get_Adc_Average(ADC_Channel_5,10);     // 得到ADC转换值         
        temp=(float)adcx*(3.3/4096);        // 得到ADC电压值             
        adcx=temp;
        temp1=adcx*100;
        LCD_ShowxNum(94,190,temp,1,16,0);   // 显示电压值整数部分          
        temp-=adcx;
        temp*=1000;
        temp2=temp/10;
        adcx=temp2;
        temp1=temp1+adcx;
        LCD_ShowxNum(110,190,temp,3,16,0X80);   // 显示电压值的小数部分
        

        POINT_COLOR=RED;
        
        // 待显示曲线上坐标值生成
        if(i<80){
             adc[i]=temp1;
        }else{
            for(j=0;j<79;j++){
                adc[j]=adc[j+1];
            }
            adc[79]=temp1;
        }
        
        /* 每两点绘制连线 */
        // 第1论
        if(i<80){
            if(i==0){
                ++i;
            }else{
                LCD_DrawLine(55+(i-1)*3, 495-adc[i-1] ,55+(i)*3, 495-adc[i]);
                ++i;
            }
        }
        // 一轮之后(要清屏)
        else{
            LCD_Fill(55,346,299,489,WHITE);     // 清屏
            for(j=0;j<i-1;j++){
                LCD_DrawLine(55+j*3, 495-adc[j], 55+(j+1)*3, 495-adc[j+1]);
            }
        }                    
    }
}    
```




----
# 实验56-UCOSII实验1-2任务调度
- 第11次实验

---
## 实验内容
- 1、将DAC模块移植到uCOS任务中;
- 2、按key_ _up删除led和beep任务;
- 3、按key1重新创建led和beep任务;
- 4、按key0挂起dac任务;
- 5、按key2恢复dac任务。
- 6、保留BEEP任务，但去掉蜂鸣声。

- 1、堆栈字节对齐
```C
_align(8) OS_STK
START_TASK_STK[START_STK_SIZE];
```
- 2、任务设置
```C
#define START_ TASK_PRIO 10
......
#define DAC_TASK_PRIO 8
#define DAC_STK_SIZE 128
......
#define LED_TASK_PRIO 7
......
```

---
## 源码

---
### main.c
```C
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "includes.h"
#include "key.h"
#include "beep.h"
//ALIENTEK 探索者STM32F407开发板 实验56
//UCOSII实验1-2 任务创建，删除，挂起，恢复  -库函数版本
//技术支持：www.openedv.com
//淘宝店铺：http://eboard.taobao.com  
//广州市星翼电子科技有限公司  
//作者：正点原子 @ALIENTEK

// 实际实验新增依赖
#include "lcd.h"
#include "adc.h"
#include <cmath>





/////////////////////////UCOSII任务堆栈设置///////////////////////////////////
// START 任务
// 设置任务优先级
#define START_TASK_PRIO  10 //开始任务的优先级设置为最低
// 设置任务堆栈大小
#define START_STK_SIZE   64
// 创建任务堆栈空间    
__align(8) OS_STK START_TASK_STK[START_STK_SIZE];
// 任务函数接口
void start_task(void *pdata);    

// 实验新增 ADC 任务堆栈设置
#define ADC_TASK_PRIO  8
#define ADC_STK_SIZE   128
__align(8) OS_STK ADC_TASK_STK[ADC_STK_SIZE];
void adc_task(void *pdata);

// LED任务
// 设置任务优先级
#define LED_TASK_PRIO  7 
// 设置任务堆栈大小
#define LED_STK_SIZE   64
// 创建任务堆栈空间    
__align(8) OS_STK LED_TASK_STK[LED_STK_SIZE];
// 任务函数接口
void led_task(void *pdata);


// 蜂鸣器任务
// 设置任务优先级
#define BEEP_TASK_PRIO  5 
// 设置任务堆栈大小
#define BEEP_STK_SIZE   64
// 创建任务堆栈空间    
__align(8) OS_STK BEEP_TASK_STK[BEEP_STK_SIZE];
// 任务函数接口
void beep_task(void *pdata);


// 按键扫描任务
// 设置任务优先级
#define KEY_TASK_PRIO  3 
// 设置任务堆栈大小
#define KEY_STK_SIZE   64
// 创建任务堆栈空间    
__align(8) OS_STK KEY_TASK_STK[KEY_STK_SIZE];
// 任务函数接口
void key_task(void *pdata);

int main(void){ 
    delay_init(168);    // 初始化延时函数 
    uart_init(115200);
    LED_Init();         // 初始化与LED连接的硬件接口
     BEEP_Init();       // 蜂鸣器初始化    
    KEY_Init();         // 按键初始化

    LCD_Init();         // LCD 初始化
    ADC_Init();         // ADC 初始化

    OSInit();           // 初始化UCOSII         
    // 创建起始任务              
    OSTaskCreate(start_task,(void *)0,(OS_STK *)&START_TASK_STK[START_STK_SIZE-1],START_TASK_PRIO );
    OSStart();    
}

// 开始任务(加入 ADC 任务的创建)
void start_task(void *pdata){
    OS_CPU_SR cpu_sr=0;
    pdata = pdata;                                  
    OSStatInit();                       // 初始化统计任务.这里会延时1秒钟左右    
    OS_ENTER_CRITICAL();                // 进入临界区(无法被中断打断)    
    OSTaskCreate(led_task,(void *)0,(OS_STK*)&LED_TASK_STK[LED_STK_SIZE-1],LED_TASK_PRIO);                                               
    OSTaskCreate(beep_task,(void *)0,(OS_STK*)&BEEP_TASK_STK[BEEP_STK_SIZE-1],BEEP_TASK_PRIO);                                           
    OSTaskCreate(key_task,(void *)0,(OS_STK*)&KEY_TASK_STK[KEY_STK_SIZE-1],KEY_TASK_PRIO);                        
    
    OSTaskCreate(adc_task,(void *)0,(OS_STK*)&ADC_TASK_STK[KEY_STK_SIZE-1],ADC_TASK_PRIO);
    
    OSTaskSuspend(START_TASK_PRIO);    // 挂起起始任务.
    OS_EXIT_CRITICAL();                // 退出临界区(可以被中断打断)
}    

// LED任务(实验要求更改为删除与重构,因此这里仿写 BEEP 任务)
void led_task(void *pdata){   
    while(1){
        // 判断是否有删除请求 
        if(OSTaskDelReq(OS_PRIO_SELF)==OS_ERR_TASK_DEL_REQ){
            OSTaskDel(OS_PRIO_SELF);    // 删除任务本身TaskLed
        }
        LED0=!LED0;
        LED1=!LED1;
        delay_ms(500);
    }                                     
}       

// 蜂鸣器任务
void beep_task(void *pdata){
    while(1){     
        // 判断是否有删除请求 
        if(OSTaskDelReq(OS_PRIO_SELF)==OS_ERR_TASK_DEL_REQ){
            OSTaskDel(OS_PRIO_SELF);    // 删除任务本身TaskLed
        }
        BEEP=1;
        delay_ms(60);
        BEEP=0;
        delay_ms(940);
    }                                     
}

// ADC 任务
void adc_task(void *pdata)
{
    u16 i=0,j=0,n,m;
    u16 adcx;
    u16 num[60];
    float temp;

    POINT_COLOR=RED; 
    LCD_ShowString(30,50,200,16,16,"Explorer STM32F4");    
    LCD_ShowString(30,70,200,16,16,"ADC TEST");    
    LCD_ShowString(30,90,200,16,16,"ATOM@ALIENTEK");
    LCD_ShowString(30,110,200,16,16,"2014/5/6");      
    POINT_COLOR=BLUE;
    LCD_ShowString(30,130,200,16,16,"ADC1_CH5_VAL:");          
    LCD_ShowString(30,150,200,16,16,"ADC1_CH5_VOL:0.000V");   
        LCD_ShowString(30,200,10,16,16,"VOL");   
        LCD_DrawLine(50,550,50,250);//??
        LCD_DrawLine(50,250,55,255);
    LCD_DrawLine(50,250,45,255);
    LCD_ShowString(450,555,10,16,16,"TIME");
    LCD_DrawLine(50,550,450,550);//??
    LCD_DrawLine(450,550,445,545);
    LCD_DrawLine(450,550,445,555);    
    while(1)
    { 
        adcx=Get_Adc_Average(ADC_Channel_5,20);
        LCD_ShowxNum(134,130,adcx,4,16,0);    
        temp=(float)adcx*(3.3/4096);         
        adcx=temp;                           
        LCD_ShowxNum(134,150,adcx,1,16,0);   
        temp-=adcx;                         
        temp=temp*1000;                           
        LCD_ShowxNum(150,150,temp,3,16,0X80); 

        if(i<60)
        {
            num[i]=temp;
            i++;
            if(j>0)
                LCD_DrawLine(45+j*5,num[j-1]+250,50+j*5,num[j]+250);
            j++;
        }
        if(i>=60)
        {
      i++;
            LCD_Fill(51,200,494,544,WHITE);
            for(m=0;m<59;m++){
                num[m]=num[m+1];
            }
            num[59]=temp;
            for(n=1;n<60;n++)
            {
                LCD_DrawLine(45+n*5,num[n-1]+250,50+n*5,num[n]+250);
            }
        }
        delay_ms(100);    
    }
}    

// 按键扫描任务
void key_task(void *pdata){    
    u8 key;                                     
    while(1){
        key=KEY_Scan(0);
        if(key==KEY0_PRES){
            // 挂起ADC任务
            OSTaskSuspend(ADC_TASK_PRIO);
        }
        else if (key==KEY2_PRES){
            // 恢复ADC任务   
            OSTaskResume(ADC_TASK_PRIO);    
        }
        else if (key==WKUP_PRES){
            // 发送删除BEEP任务请求，任务睡眠，无法恢复
            OSTaskDelReq(BEEP_TASK_PRIO);    
            // 删除LED任务，LED停止闪烁
            OSTaskDelReq(LED_TASK_PRIO);        
        }
        else if(key==KEY1_PRES){
            // 重新创建任务beep 
            OSTaskCreate(beep_task,(void *)0,(OS_STK*)&BEEP_TASK_STK[BEEP_STK_SIZE-1],BEEP_TASK_PRIO);                                          
            // 重新创建 LED 任务
            OSTaskCreate(led_task,(void *)0,(OS_STK*)&LED_TASK_STK[LED_STK_SIZE-1],LED_TASK_PRIO);
        }   
         delay_ms(10);
    }
}
```

