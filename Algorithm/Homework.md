# 第2章 递归与分治策略 
## 2.6 棋盘覆盖
### 完成书上的棋盘骨牌的设计
- 要求:
  - 补全书上的算法设计代码
  - 设计UI界面显示解决方案
  - 写报告
#### 碎碎念
- 关于语言
  - 语言使用不做要求,你喜欢就好  

#### 关于实验报告
- 实验目的及要求
  - 自拟
  - 不能写得太大
    - 如: 提高计算机能力(
  - 也不要写的太小
    - 如:熟悉棋盘覆盖 
  - 要写的比较合适
    - 比如:加深对分治法的理解... 
- 实验内容
- 算法描述
- 实验结果
- 总结
  - 可以每个实验写一个总结
  - 也可以做完所有实验之后写一个总的总结
  - > 注意所有实验的总结和单个实验的总结写法是不一样的
    - > 至少从对象来考虑
      - > 总的总结是面对整个课程实验的总结
      - > 每个实验的总结是相对于这一章的总结(毕竟规划上是一章一份作业)

#### 设计思路
- 关于算法
  - 没什么好说的,书上已经给出来了 
    - 主体思路 


- 关于上色
  - 骨牌号数传递的时候传回传区域号[1(左上),2(右上),3(左下),4(右下)]
    - 每次递归结束都要及时给骨牌上色
      - 不及时上色的话就要将参数传出,并再次判断,浪费时间空间
      - 这就要求整个类的设计应当就是一个界面,而非界面与算法分离的设计
        - 因为界面与算法的关联性比较强就不分离了

---
## 2.9 线性时间选择 


---
# 第3章 动态规划
## 3.1 矩阵连乘问题
- 10.23布置
- 了解了用Python使用动态规划法解决矩阵连乘问题的实现方式
- 找出最优解的性质，并刻画其结构特征
  - 将矩阵连乘积AiAi+1……Aj记为A[i：j]。问题在于计算A[1：n]的最优计算次序。
  - 设这个计算次序在矩阵Ak和Ak+1之间将矩阵链断开($1<=k<$n),使其完全加括号方式为（（A1……Ak）（AK+1……An）），这样就将原问题分解为两个子问题;
  - 按此计算次序，计算A[1：n]的计算量就等于计算A[1：k]的计算量加上A[k+1：n]的计算量，再加上A[1：k]和A[k+1:n]相乘的计算量。
  - 计算A[1：n]的最优次序包含了计算A[1：k]和A[k+1：n]这两个子问题的最优计算次序，以此类推，将A[1：k]和A[k+1：n]递归的分解下去，求出每个子问题的最优解，子问题的最优解相乘便得到原问题的最优解。
- 递归地定义最优值
  - 对于矩阵连乘积的最优计算次序的问题，设计算A[i：j]，(1<=i<=j<=n),所需要的最小数乘次数为m[i][j]，则原问题的最优值为m[1][n]。
  - 当i=j时，A[i：j]=Ai为单一的矩阵，则无需计算，所以m[i][j]=0，i=j=1，2，……，n。即对应的二维表对角线上的值全为0。
  - 当i<j时，这就需要用上面的最优子结构性质来计算m[i][j]:若计算A[i:j]的最优次序在Ak和Ak+1之间断开(i<=k<j),则m[i][j]=m[i][k]+m[k+1][j]+pi-1*pk*pj,k的位置只有j-i种可能，即k属于集合{i，i+1，……，j-1}，所以k是这j-i个位置中使计算量达到最小的那个位置。
  - 所以m[i][j]可以递归地定义为
    $$
    y=
    \begin{cases}
    0,\quad i=j\\
    min(m[i][k]+m[k+1][j]+pi-1*pk*pj), \quad i<j ,i<=k<j 
    \end{cases}
    $$
  - 将对应于m[i][j]的断开位置k记为s[i][j]，在计算出最优值m[i][j]后，可递归地由s[i][j]构造出相应的最优解
- 以自底向上的方式计算出最优值


---
### 随笔
#### Java二维数组初始化
- [参考链接](https://blog.csdn.net/Hurricane_m/article/details/89504445)
```Java
*1-1    int k[][] = {{},{},{},{}};
 
int a[][] = {{1,2,3},{4,5,6},{7,8,9,10}};
int b[][] = {{},{2},{},{3,5}};
```
```Java
第二种初始化方式  int [][]k = new int[i][j];
 
*2-1    int [][]m = new int[3][];
*2-2    int [][]n = new int[3][2];

```

---
## 3.8 流水作业调度
### 算法实现


### 最优调度证明
- $min \{ b_{π(i)}, a_{π(j)} \} \geq min \{ b_{π(j)}, a_{π(i)} \}$                               


---
## 3.9 0-1背包问题
- 学会了使用动态规划法解决0-1背包问题
- 当放入第一个物品时，在背包所能承受的重量内，计算背包拥有的物品总价格，并进行标记，当背包所能承受的重量大于等于其重量时，都可以放入该物品，背包拥有的物品总价格为6。

接着我们放入物品b，放入之前，一是要判断背包是否所能承受其重量，二是判断放入之后与放入之前拥有的物品总价格哪个最大，如表格第二行所示，当背包所能承受的重量大于等于2时，都可以放入物品b，但是，物品b在背包容量为[2,3]的时候，放入之后的总价格3不如放入之前的总价格6大，所以不放入。

当背包所能承受的重量等于4时，放入物品b后，背包所能承受的重量4减去物品b的重量2后，剩余的所能承受的重量2还可以放入物品a，此时背包拥有的物品总价格为物品a和物品b的总价格之和，即为9，大于放入之前的物品总价格6，所以此时背包拥有的物品总价格最大为9。

分析可知，在一层循环遍历下，我们需要一个一维数组保存背包所能承受的最大重量与其拥有的物品总价格，并不断更新。



---
### 小练习



### 贪心算法解背包问题


---
### 回溯法解0-1背包问题


---
### 分支限界法解0-1背包问题


---
# 第4章 贪心算法



---
# 第5章 回溯法