# 前言

## 关于点名

- 共 16 次课,5 分
- 课堂抽查
- 得分=$\frac{抽查到的到课次数}{抽查到的总次数}$
- 第 12 周开始点名送分
  - 没到扣分

---

## 关于作业

- 每章一次作业
- 每次作业都有报告,需要演示

---

## 关于考题

- 时间复杂度递推公式必考
- 流水作业调度是最优调度的证明必考
- 矩阵连乘和 0-1 背包问题选考一题
  - 要求画出图解

---

## 关于考试

- 考试(卷面)成绩低于 50 分则`直接挂科`

---

## 关于 8 个实验

- 合计 35 分
- 时间
  - 考试后
- 抽查一个
  - 若不会则自选一个接收检查
    - 这样做的话等级最多是`中`
      - $int(70*0.35)=24分$
    - 若还不会则直接 0 分
  - 若会则正常回答

---

### 题型

- 简答题(在所给范围内)
- 时间复杂度分析
  - 给段代码,根据递推公式给出 O 的形式的时间复杂度
  - 直接写结果不给分
- 0-1 背包问题的动态规划算法解题过程
- 0-1 背包问题分支限界算法的解题过程
- 流水作业调度问题及其证明
- 贪心算法出个题目
  - 具体没说
- 随机化算法的理解
  - 具体没说
- 以下`题型`会选择考察
  - 问题 1:排考试时间
    - 一方面要总时间尽可能短(假设教室没问题),另一方面一个同学所学的任意两门课不能同时考
  - 问题 2:仓库隔间
    - 仓库存放若干种化学制品,其中某些制品相互接触有可能引发爆炸,为预防事故,将其隔间存放.要达到安全要求,至少将该仓库隔成多少间?
  - 问题:青蛙跳台阶(✖)
    - 一次只能跳 1 阶或 2 阶,问有多少种跳法

---

# 第 2 章 递归与分治策略

## 2.1 递归的概念

### 递归的定义

- 若一个对象部分地包含它自己,或者用它自己给自己定义,则称这个对象是递归的;
- 若一个过程**直接地或间接地调用自己**,则称这个过程是递归的过程;

## 2.2 分治法的基本思想

- 将要求解的**较大规模**的问题分割成**若干个**更小规模的子问题。
- 对这**若干子问题**分别求解。如果子问题的规模仍然不够小，则再划分为若干个子问题，如此**递归**的进行下去，直到问题规模足够小，很容易求出其解为止。
  ![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_e4d691d94b07753a52333888c1de0218.png)

---

### 算法总体思想

- 将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解。
  ![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_f330c38443df2abd2fc340ce293af352.png)
- 分治法的设计思想是，将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。
  - 凡治众如治寡，分数是也。
    ----孙子兵法

### 分治策略的基本思想

1. 将原始问题划分或者归结为规模较小的子问题
2. 递归或迭代求解每个子问题
3. 将子问题的解综合得到原问题的解

### 合并排序

![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_514f48cd890853bb801533402b02982d.png)

### 分治法的基本步骤

```Java
public static void  mergeSort(Comparable a[],int left,int right){
    if(left == right)           // 解决小规模问题
    else if(left < right){      //至少有两个元素
        int i = (left+right)/2; //取中点,分解问题
        mergeSort(a, left, i);
        mergeSort(a, i+1, right);
        merge(a, b, left, i, right);    //合并数组到b
        //复制回数组a,将各子问题的解合并为原问题的解
        copy(a, b, left, right);
    }
}
```

- 复杂度分析
  ![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_02c411722269e9623b22fa2ec9ff33fa.png)

```Java
divide-and-conquer(P){
    if ( |P| <= n0) adhoc(P);   //解决小规模的问题
    divide P into smaller subinstances P1,P2,...,Pk；//分解问题
    for (i=1,i<=k,i++)
      yi=divide-and-conquer(Pi);  //递归的解各子问题
    return merge(y1,...,yk);  //将各子问题的解合并为原问题的解
}
```

### 分治法的复杂性分析

- 一个分治法将规模为 n 的问题分成 k 个规模均为 n／m 的子问题去解。设分解阀值 n0=1，且 adhoc 解规模为 1 的问题耗费 1 个单位时间,设将原问题分解为 k 个子问题以及用 merge 将 k 个子问题的解合并为原问题的解需用 f(n)个单位时间。用 T(n)表示该分治法解规模为|P|=n 的问题所需的计算时间，则有:
- ![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_357520b88b08edeee9fdd55d0fd191d0.png)
- 通过迭代法求得方程的解：
- ![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_469396c05224c1f0fec839c8dbc14fc1.png)
- 注意：递归方程及其解只给出 n 等于 m 的方幂时 T(n)的值，但是如果认为 T(n)足够平滑，那么由 n 等于 m 的方幂时 T(n)的值可以估计 T(n)的增长速度。通常假定 T(n)是单调上升的，从而当 mi≤n<mi+1 时，T(mi)≤T(n)<T(mi+1)。
- 人们从大量实践中发现，在用分治法设计算法时，最好使子问题的规模大致相同。即将一个问题分成**大小相等的 k 个子问题**的处理方法是行之有效的。这种使子问题**规模大致相等**的做法是出自一种**平衡(balancing)子问题**的思想，它几乎总是比子问题规模不等的做法要好。

### 分治法的适用条件

分治法所能解决的问题一般具有以下几个特征：

- 该问题的规模缩小到一定的程度就可以容易地解决；
- 该问题可以分解为若干个规模较小的**相同**问题，即该问题具有**最优子结构**性质
- 利用该问题分解出的子问题的解可以**合并**为该问题的解；
- 该问题所分解出的各个子问题是**相互独立**的，即子问题之间不包含公共的子问题。
  - 这条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治法，但一般用动态规划较好。

## 2.3 二分搜索技术

给定已按升序排好序的 n 个元素 a[0:n-1]，现要在这 n 个元素中找出一特定元素 x。

## 2.4 大整数的乘法问题

请设计一个**有效的算法**，可以进行**两个 n 位大整数**的乘法运算

- 小学的方法：O($n^2$)
  - 效率太低
- 分治法:  
  X = $a \times 2 ^ \frac{n}{2} + b$  
  Y = c 2n/2 + d  
  XY = ac 2n + (ad+bc) 2n/2 + bd  
  ![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_2c32d5836382e445e018310aa117ef4f.png)
- 为了降低时间复杂度，必须减少乘法的次数。
- XY = ac 2n + ((a-c)(b-d)+ac+bd) 2n/2 + bd
- ![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_ca9001b61f67100857d7c2f38b48a262.png)
- 细节问题：两个 XY 的复杂度都是 O(nlog3)，但考虑到 a+c,b+d 可能得到 m+1 位的结果，使问题的规模变大，故不选择第 2 种方案。
- 如果将大整数分成更多段，用更复杂的方式把它们组合起来，将有可能得到更优的算法。
- 最终的，这个思想导致了**快速傅利叶变换**(Fast Fourier Transform)的产生。该方法也可以看作是一个复杂的分治算法，对于大整数乘法，它能在**O(nlogn)**时间内解决。
- 是否能找到**线性时间的算法？？？**目前为止还没有结果。

## 2.5 Strassen 矩阵乘法

- 传统方法：O(n3)
- A 和 B 的乘积矩阵 C 中的元素 C[i,j]定义为:
- ![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_d4162477758d9455fc1976715f91799c.png)
- 若依此定义来计算 A 和 B 的乘积矩阵 C，则每计算 C 的一个元素 C[i][j]，需要做 n 次乘法和 n-1 次加法。因此，算出矩阵 C 的 个元素所需的计算时间为 O(n3)

## 2.6 棋盘覆盖问题

- 在一个 2k×2k 个方格组成的棋盘中，**恰有一个方格**与其他方格不同，称该方格为一**特殊方格**，且称该棋盘为一**特殊棋盘**。在棋盘覆盖问题中，要用图示的**4 种不同形态**的 L 型骨牌覆盖给定的特殊棋盘上**除特殊方格以外**的所有方格，且**任何 2 个 L 型骨牌不得重叠覆盖**。
  ![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_eea2f899622199adb059b0d39a16cc6f.png)
  > 每个 L 型骨牌在棋盘上的摆放位置都是有限的,所以我认为可以依次摆放四个 L 型骨牌
- 当**k>0**时，将 2k×2k 棋盘分割为 4 个 2k-1×2k-1 子棋盘(a)所示。
- **特殊方格必位于 4 个较小子棋盘之一中**，**其余 3 个**子棋盘中无特殊方格。为了将这 3 个无特殊方格的子棋盘转化为特殊棋盘，可以用一个 L 型骨牌覆盖这 3 个较小棋盘的会合处，如 (b)所示，从而将原问题转化为 4 个较小规模的棋盘覆盖问题。递归地使用这种分割，直至棋盘简化为棋盘 1×1。
- ![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_5d6e879805ce381c2c5ed41a9a2160fd.png)
  ![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_afb19a8b4cb4156a02cf51c96dde4657.png)
- **到这里算法就结束了,设计方面要写报告作为平时作业**

---

## 2.7 合并排序

---

## 2.8 快速排序

---

## 2.9 线性时间选择

- 给定线性序集中 n 个元素和一个整数 k，1≤k≤n，要求找出这**n**个元素中**第 k 小**的元素。（**比如求中位数**）

```java
private static Comparable randomizedSelect(int p,int r,int k)
   {
      if (p==r) return a[p];
      int i=randomizedpartition(p,r),
          j=i-p+1;
      if (k<=j) return randomizedSelect(p,i,k);
      else return randomizedSelect(i+1,r,k-j);
   }
```

- 在最坏情况下，算法 randomizedSelect 需要 O(n2)计算时间但可以证明，算法 randomizedSelect 可以在 O(n)平均时间内找出 n 个输入元素中的第 k 小元素。
- 如果能在**线性时间**内找到一个**划分基准**，使得按这个基准所划分出的**2 个子数组**的长度都至少为原数组长度的**ε**倍(0<ε<1 是某个正常数)，那么就可以在最坏情况下用 O(n)时间完成选择任务。
  - 例如，若 ε=9/10，算法递归调用所产生的子数组的长度至少缩短 1/10。所以，在最坏情况下，算法所需的计算时间 T(n)满足递归式 T(n)≤T(9n/10)+O(n) 。由此可得 T(n)=O(n)。
- 将 n 个输入元素划分成$\lceil n/5 \rceil$个组，每组 5 个元素，只可能有一个组不是 5 个元素。用任意一种排序算法，将每组中的元素排好序，并取出每组的中位数，共 n/5 个。

```Java
private static Comparable select (int p, int r, int k)
   {
      if (r-p<5) {
        //用某个简单排序算法对数组a[p:r]排序;
        bubbleSort(p,r);
        return a[p+k-1];
        }
      //将a[p+5*i]至a[p+5*i+4]的第3小元素
      //与a[p+i]交换位置;
      //找中位数的中位数，r-p-4即上面所说的n-5
      for ( int i = 0; i<=(r-p-4)/5; i++ )
      {
         int s=p+5*i,
             t=s+4;
         for (int j=0;j<3;j++) bubble(s,t-j);
         MyMath.swap(a, p+i, s+2);
      }
      Comparable x = select(p, p+(r-p-4)/5, (r-p+6)/10);
      int i=partition(p,r,x),
          j=i-p+1;
      if (k<=j) return select(p,i,k);
      else return select(i+1,r,k-j);
   }
```

---

## 分治法的适用条件

分治法所能解决的问题一般具有以下几个特征

- 该问题的规模缩小到一定的程度就可以容易地解决；
- 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质
- 利用该问题分解出的子问题的解可以合并为该问题的解；
- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

---

# 第 3 章 动态规划

---

## 3.1 矩阵连乘

---

## 3.2 动态规划算法的基本要素

---

## 3.3 最长公共子序列

---

## 3.4 凸多边形最优三角剖分

---

## 3.5 多边形游戏

---

## 3.6 图像压缩

---

## 3.7 电路布线

## 3.8 流水作业调度

### 作业

- 证明流水作业调度满足最优调度:  
  $min \{ b_{π(i)}, a_{π(j)} \} \geq min \{ b_{π(j)}, a_{π(i)} \}$

---

## 3.9 0-1 背包问题

### 例题

- 价值数组
  - v={8,10,6,3,7,2}
- 重量数组
  - w={4,6,2,2,5,1}
- 背包容量
  - C=12
- 价值/重量数组
  - $\frac{v}{M} = \{ 2, \frac{5}{3}, 3, 1.5, \frac{7}{5}, 2 \}$
- 价重比递减索引+1
  - indexVM = {3, 1, 6, 2, 4, 5}
  - indexVMW = {2, 4, 1, 6, 2, 5}
  - 答案{3,1,6,5}
  - 价值为 24
    > 上面这个是臆想,不是解法,下面是的 0-
- 解答
  ![](../res/img/Algorithm/0-1背包问题-动态规划算法例题.png)

---

## 3.10 最优二叉搜索树

---

# 第 4 章 贪心算法

---

## 4.1 活动安排问题

---

## 4.2 贪心算法基本要素

---

## 4.3 最优装载

---

## 4.4 哈弗曼编码

---

## 4.5 单源最短路径

---

## 4.6 最小生成树

---

## 4.7 多机调度问题

---

## 4.8 贪心算法的理论基础

---

# 第 5 章 回溯法

---

## 5.1 回溯法的算法框架

---

## 5.2 装载问题

---

## 5.3 批处理作业调度

---

## 5.4 符号三角形问题

---

## 5.5 n 后问题

- python 解法 1

```python
global N
N = 4


def printSolution(board):
    for i in range(N):
        for j in range(N):
            print(board[i][j], end="")
        print()
    print()


def isSafe(board, row, col):
    for i in range(col):
        if board[row][i] == 1:
            return False
    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False
    for i, j in zip(range(row, N, 1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False
    return True


def solveNQUtil(board, col):
    if col >= N:
        printSolution(board)
    else:
        for i in range(N):
            if isSafe(board, i, col):
                board[i][col] = 1
                solveNQUtil(board, col + 1)
                board[i][col] = 0
    return False


def solveNQ():
    # 写成这样更具适应性
    # board = [[0 for i in range(N)] for j in range(N)]
    board = [[0, 0, 0, 0],
             [0, 0, 0, 0],
             [0, 0, 0, 0],
             [0, 0, 0, 0]
             ]

    if not solveNQUtil(board, 0):
        print("Solution does not exist")
        return False

    printSolution(board)
    return True


if __name__ == "__main__":
    solveNQ()

# output
# 0010
# 1000
# 0001
# 0100

# 0100
# 0001
# 1000
# 0010
```

---

## 5.6 0-1 背包问题

---

## 5.7 最大团问题

---

## 5.8 图的 m 着色问题

---

# 复习

---

## 最后一节课

- 分治法
- 动态规划
- 贪心算法

---

## 简答题

---

1. 什么是最坏情况时间复杂性？什么是平均情况时间复杂性？

- 最坏情况下的时间复杂性和平均时间复杂性考察的是  n  固定时，不同输入实例下的算法所耗时间。

  - 最坏情况时间复杂性
    - 取的是输入实例中最大的时间复杂度：
  - 平均时间复杂性
    - 是所有输入实例的处理时间与各自概率的乘积和：

  <!-- ![](../res/img/Algorithm/时间复杂性.png) -->

  ![20220328182954](http://cdn.ayusummer233.top/img/20220328182954.png)

  <!-- ![](../res/img/Algorithm/时间复杂度.png) -->

  ![20220328183025](http://cdn.ayusummer233.top/img/20220328183025.png)

  - `N`:问题的规模
  - `I`:输入

---

2. 什么是递归算法？什么是递归函数？

- `递归算法`:直接或间接地调用自身的算法
- `递归函数`:用函数自身给出定义的函数

---

3. 递归函数的二要素是什么？

- 边界条件
- 递归方程

<!-- ![](../res/img/Algorithm/递归函数的二要素.png) -->

![20220328183049](http://cdn.ayusummer233.top/img/20220328183049.png)

---

4. 分治法的设计思想是什么？

- 将要求解的较大规模的问题分割成若干个更小规模的子问题。
- 对这若干子问题分别求解。如果子问题的规模仍然不够小，则再划分为若干个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止。

<!-- ![](../res/img/Algorithm/分治法的设计思想.png) -->

## ![20220328183103](http://cdn.ayusummer233.top/img/20220328183103.png)

5. 什么叫问题的最优子结构性质？

- 最优子结构性质，即问题的最优解包含着其子问题的最优解，其实质就是能否将原问题分解成若干规模较小的子问题，以及如何分解。

---

6. 动态规划基本步骤是什么？

- **分析最优的结构**，找出**最优解**的性质，并刻划其**结构特征**。
- 递归地**定义最优值**
- 以**自底向上**的方式计算出**最优值**。
- 根据计算最优值时得到的信息`s[i,j]`，构造最优解。

---

- (1)划分阶段：
  - 按照问题的时间或空间特征，把问题分为若干个阶段。
  - 在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
- (2)确定状态和状态变量：
  - 将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
- (3)确定决策并写出状态转移方程：
  - 因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。
  - 所以如果确定了决策，状态转移方程也就可写出。
  - 但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
- (4)寻找边界条件：
  - 给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。
  - 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。
  - 实际应用中可以按以下几个简化的步骤进行设计：
    - （1）分析最优解的性质，并刻画其结构特征。
    - （2）递归的定义最优解。
    - （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值
    - （4）根据计算最优值时得到的信息，构造问题的最优解

---

1. 动态规划算法的基本要素是什么？
   - 举例说明一些可以用动态规划算法解决的问题。

- 动态规划算法的基本要素
  - 1.最优子结构
    - 最优子结构性质，即问题的最优解包含着其子问题的最优解，其实质就是能否将原问题分解成若干规模较小的子问题，以及如何分解。
    - 最优子结构是问题能用动态规划算法求解的前提。
    - 在动态规划算法中，利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。
  - 2.重叠子问题
    - 在用递归算法自顶向下求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。
    - 动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要此子问题时，只要简单地用常数时间查看一下结果。
    - 通常，不同的子问题个数随问题的大小呈多项式增长。因此，用动态规划算法通常只需要多项式时间，从而获得较高的解题效率。
- 举例说明一些可以用动态规划算法解决的问题
  - 矩阵连乘问题
  - 最长公共子序列问题
  - 流水作业调度问题
  - `0-1`背包问题

---

8. 说明分治法与动态规划法的相同点和不同之处？

- `相同点`:基本思想都是将待求解问题分解成若干个子问题先求解子问题,然后从这些子问题的解得到原问题的解
- 不同之处
  - 适合用动态规划法求解的问题,经分解得到的子问题往往不是相互独立的.若用分治法解这类问题,则分解得到的子问题数目太多,以至于最后解决问题需要消耗指数时间;
  - 不同子问题的数目常常只有多项式两级,在用分治法求解时,有些子问题都被重复计算了许多次.动态规划法保存已解决的子问题的答案,在需要时再找到已得到的答案,可以避免大量重复计算;

---

9. 贪心算法的两个重要要素是什么？
   - 举例说明一些可以用贪心算法解决的问题。

- 贪心算法的两个重要要素
  - 贪心选择性质
  - 最优子结构性质
- 举例说明一些可以用贪心算法解决的问题
  - 背包问题
  - 单源最短路径问题
  - 活动安排问题

---

10. 什么叫贪心选择性质？

- 所求问题的整体最优解可以通过一系列局部最优的选择来得到

---

11. 贪心算法与动态规划算法的的相同点和不同之处？

- 相同点
  - 二者都要求问题具有最优子结构性质
- 不同之处
  - 贪心算法要求问题具有贪心选择性质,这是贪心算法可行的第一个基本要素,也是贪心算法和动态规划算法的主要区别

---

12. 背包问题与 0－1 背包问题有何区别？

- 背包问题和 0－1 背包问题区别为：
  - 背包问题可以用贪心算法求解,而 0-1 背包问题不能用贪心算法求解
  - 循环变量不同、约束条件不同、最大总价值不同。
    - 循环变量不同
      - `背包问题`:须先求出列坐标 j 较小的元素，故让循环变量 j 的值从小到大递增。
      - `0－1背包问题`:须先求出列坐标 j 较大的元素，故让循环变量 j 的值从大到小递减。
    - 约束条件不同
      - `背包问题`:约束条件是给定几种物品，物品可以取无限次。
      - `0－1背包问题`:约束条件是给定几种物品，物品只可以取一次。
    - 最大总价值不同
      - `背包问题`:若取了 1 件第 i 个物品，则总容量变为 j－W［i］，剩下的仍可以在前 i 件物品中去取，其最大总价值为$B［i］［j－W［i］］ ＋ P［i］$。
      - `0－1背包问题`:若取了 1 件第 i 个物品，则总容量变为 j－W［i］，剩下的只能在前 i－1 件物品中去取了，其最大总价值为$B［i－1］［j－W［i］］ ＋ P［i］$。

---

13. 回溯法与分支限界法之间的相同点是什么？不同之处在哪些方面？

- `相同点`:他们同是在问题的解空间树上搜索问题解的算法;
- 不同之处
  - 求解目标
    - `回溯法`的求解目标是找出解空间树中满足约束条件的所有解
    - `分支限界法`的求解目标是找出满足约束条件的一个解,或是在满足约束条件的解中找出在某种意义下的最优解
  - 搜索方式的不同
    - `回溯法`用深度优先搜索
    - `分支限界法`用广度优先搜索

---

14. 分支限界法基本思想是什么？

- 分支限界法常以广度优先或以最小耗费(最大收益)优先的方式搜索问题的解空间树

---

15. 常用的剪枝函数有哪两类？

- 约束函数
  - `功能`:用约束函数在扩展结点处剪去不满足约束的子树,保留合法节点；
- 限界函数
  - `功能`:用限界函数剪去得不到最优解的子树。

---

16. 常见的两种分支限界法是什么？

- `队列式(FIFO)分支限界法`:按照先进先出原则选取下一个结点为扩展节点
- `优先队列式分支限界法`:按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点

---

19. 什么是 P 问题和 NP 问题？

- `P问题`:如果一个问题能找到一个能在多项式时间里解决它的算法,那么这个问题就属于 P 问题
- `NP问题`:NP 问题(Non-Deterministic Polynomial)不是非 P 类问题,是多项式复杂程度的非确定性问题.是指可以在多项式的时间里验证一个解的问题;NP 问题的另一个定义是:可以再多项式的时间里猜出一个解的问题;

---

22. 什么是 NP 完全问题？

- `NPC问题(Complete)`:如果问题的所有可能答案,都是可以在多项式时间内进行正确与否验算的话,就叫做完全多项式非确定问题

---

23. NP-Hard 问题

- `NP-Hard`问题要比 NPC 问题的范围广
- `NP-Hard`问题同样难以找到多项式的算法,它不一定是 NP 问题;
- 即使`NPC问题`发现了多项式级的算法,`NP-Hard`问题有可能仍然无法得到多项式级的算法;
- 事实上,由于`NP-Hard`放宽了限定条件,它将有可能比所有的`NPC问题`的时间复杂度更高而更难以解决

---

## 题型

- 简答题(在所给范围内)

---

### 时间复杂度分析

- 给段代码,根据递推公式给出 O 的形式的时间复杂度
- 直接写结果不给分
<!-- - ![时间复杂度规则](../res/img/Algorithm/时间复杂度规则.png) -->
- ![20220328183125](http://cdn.ayusummer233.top/img/20220328183125.png)

---

### 0-1 背包问题

---

#### 动态规划算法

- 价值数组
  - v={8,10,6,3,7,2}
- 重量数组
  - w={4,6,2,2,5,1}
- 背包容量
  - C=12
- 价值/重量数组
  - $\frac{v}{M} = \{ 2, \frac{5}{3}, 3, 1.5, \frac{7}{5}, 2 \}$
- 价重比递减索引+1
  - indexVM = {3, 1, 6, 2, 4, 5}
  - indexVMW = {2, 4, 1, 6, 2, 5}
  - 答案{3,1,6,5}
  - 价值为 24
    > 上面这个是臆想,不是解法,下面是的 0-
- 解答

  <!-- ![](../res/img/Algorithm/动态规划解0-1背包.png)   -->

  ![20220328183209](http://cdn.ayusummer233.top/img/20220328183209.png)

  <!-- ![](../res/img/Algorithm/0-1背包问题-动态规划算法例题.png)   -->

  ![20220328183234](http://cdn.ayusummer233.top/img/20220328183234.png)

---

#### 分支限界算法

[参考链接](https://www.bilibili.com/video/BV1gb411G7FH?from=search&seid=5119835224121889818)

---

### 流水作业调度问题及其证明

<!-- ![](../res/img/Algorithm/流水作业调度.png)   -->

![20220328183252](http://cdn.ayusummer233.top/img/20220328183252.png)

---

- 贪心算法出个题目
  - 具体没说

---

- 随机化算法的理解
  - 具体没说

---

- 以下`题型`会选择考察
  - 问题 1:排考试时间
    - 一方面要总时间尽可能短(假设教室没问题),另一方面一个同学所学的任意两门课不能同时考
  - 问题 2:仓库隔间
    - 仓库存放若干种化学制品,其中某些制品相互接触有可能引发爆炸,为预防事故,将其隔间存放.要达到安全要求,至少将该仓库隔成多少间?
  - 问题:青蛙跳台阶(✖)
    - 一次只能跳 1 阶或 2 阶,问有多少种跳法
- 图的 m 着色问题
